<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive KNN Visualization</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-white dark:bg-gray-900 text-gray-900 dark:text-gray-100 transition-colors duration-200">
    <body class="bg-white dark:bg-gray-900 text-gray-900 dark:text-gray-100 transition-colors duration-200">
        <a href="../algorithms.html" style="position: fixed; top: 20px; left: 20px; z-index: 1000; background: #bbbbbb; color: #000000; border: 1px solid rgba(52, 152, 219, 0.2); border-radius: 5px; padding: 8px 16px; font-family: 'Roboto Mono', monospace; font-size: 14px; font-weight: 500; cursor: pointer; text-decoration: none; display: flex; align-items: center; gap: 8px; transition: all 0.3s ease;">
            <span style="font-size: 18px;">←</span> Return to Algorithms
        </a>
    <div class="container mx-auto px-4 py-8">
        <h1 class="text-3xl font-bold mb-6 text-center text-[#3498db] dark:text-[#3498db]">K-Nearest Neighbors Visualization</h1>
        
        <div class="flex flex-col lg:flex-row gap-6">
            <!-- SVG Visualization Container -->
            <div class="w-full lg:w-2/3 bg-white dark:bg-gray-800 rounded-lg shadow-lg p-4">
                <div class="w-full h-[600px] relative" id="visualization-container">
                    <svg id="visualization" class="w-full h-full" viewBox="0 0 1000 600"></svg>
                </div>
                <div class="mt-2 flex justify-between items-center text-sm">
                    <div class="flex items-center gap-2">
                        <span class="inline-block w-3 h-3 rounded-full bg-blue-500"></span>
                        <span>Class 1</span>
                    </div>
                    <div class="flex items-center gap-2">
                        <span class="inline-block w-3 h-3 rounded-full bg-red-500"></span>
                        <span>Class 0</span>
                    </div>
                </div>
            </div>
            
            <!-- Controls Panel -->
            <div class="w-full lg:w-1/3 bg-white dark:bg-gray-800 rounded-lg shadow-lg p-4">
                <h2 class="text-xl font-semibold mb-4 text-[#3498db] dark:text-[#3498db]">Controls</h2>
                
                <div class="space-y-6">
                    <!-- Data Generation -->
                    <div>
                        <h3 class="text-lg font-medium mb-2">Data</h3>
                        <div class="flex flex-col gap-2">
                            <div class="flex items-center justify-between">
                                <label for="num-points" class="mr-2">Number of Points:</label>
                                <input type="number" id="num-points" min="10" max="200" value="50" class="w-20 px-2 py-1 border rounded dark:bg-gray-700 dark:border-gray-600 dark:text-white text-base">
                            </div>
                            <div class="flex items-center justify-between">
                                <label for="data-pattern" class="mr-2">Data Pattern:</label>
                                <select id="data-pattern" class="w-40 px-2 py-1 border rounded dark:bg-gray-700 dark:border-gray-600 dark:text-white text-base">
                                    <option value="blobs">Blobs</option>
                                    <option value="circle" selected>Circle</option>
                                    <option value="moons">Moons</option>
                                    <option value="spiral">Spiral</option>
                                </select>
                            </div>
                            <div class="flex items-center justify-between">
                                <label for="noise-level" class="mr-2">Noise Level:</label>
                                <input type="range" id="noise-level" min="0" max="0.5" step="0.05" value="0.1" class="w-40">
                                <span id="noise-value" class="text-sm">0.1</span>
                            </div>
                            <button id="generate-data" class="bg-[#3498db] hover:bg-[#4A4ACB] text-white font-medium py-2 px-4 rounded transition">Generate New Data</button>
                        </div>
                    </div>
                    
                    <!-- KNN Parameters -->
                    <div>
                        <h3 class="text-lg font-medium mb-2">KNN Parameters</h3>
                        <div class="flex flex-col gap-2">
                            <div>
                                <label for="k-value" class="block mb-1">K Value (number of neighbors):</label>
                                <input type="range" id="k-value" min="1" max="15" step="2" value="5" class="w-full">
                                <div class="flex justify-between text-sm">
                                    <span>1</span>
                                    <span id="k-value-display">5</span>
                                    <span>15</span>
                                </div>
                            </div>
                            <div class="flex items-center justify-between">
                                <label for="distance-metric" class="mr-2">Distance Metric:</label>
                                <select id="distance-metric" class="w-40 px-2 py-1 border rounded dark:bg-gray-700 dark:border-gray-600 dark:text-white text-base">
                                    <option value="euclidean" selected>Euclidean</option>
                                    <option value="manhattan">Manhattan</option>
                                    <option value="chebyshev">Chebyshev</option>
                                </select>
                            </div>
                            <div class="flex items-center justify-between">
                                <label for="weight-type" class="mr-2">Weighting:</label>
                                <select id="weight-type" class="w-40 px-2 py-1 border rounded dark:bg-gray-700 dark:border-gray-600 dark:text-white text-base">
                                    <option value="uniform" selected>Uniform</option>
                                    <option value="distance">Distance-weighted</option>
                                </select>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Test Point Controls -->
                    <div>
                        <h3 class="text-lg font-medium mb-2">Test Point</h3>
                        <div class="flex flex-col gap-2">
                            <div class="flex items-center gap-2">
                                <input type="checkbox" id="enable-test-point" class="w-4 h-4" checked>
                                <label for="enable-test-point">Enable Test Point</label>
                            </div>
                            <div id="test-point-controls">
                                <div class="flex items-center justify-between mb-2">
                                    <label for="test-point-x" class="mr-2">X1 Coordinate:</label>
                                    <input type="range" id="test-point-x" min="0" max="10" step="0.1" value="5" class="w-40">
                                    <span id="test-point-x-value" class="text-sm">5.0</span>
                                </div>
                                <div class="flex items-center justify-between">
                                    <label for="test-point-y" class="mr-2">X2 Coordinate:</label>
                                    <input type="range" id="test-point-y" min="0" max="10" step="0.1" value="5" class="w-40">
                                    <span id="test-point-y-value" class="text-sm">5.0</span>
                                </div>
                                <button id="classify-btn" class="mt-2 bg-[#3498db] hover:bg-[#4A4ACB] text-white font-medium py-2 px-4 rounded transition w-full">Classify Test Point</button>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Visualization Options -->
                    <div>
                        <h3 class="text-lg font-medium mb-2">Visualization Options</h3>
                        <div class="flex flex-col gap-2">
                            <div class="flex items-center gap-2">
                                <input type="checkbox" id="show-decision-boundary" class="w-4 h-4" checked>
                                <label for="show-decision-boundary">Show Decision Boundary</label>
                            </div>
                            <div class="flex items-center gap-2">
                                <input type="checkbox" id="show-voronoi" class="w-4 h-4">
                                <label for="show-voronoi">Show Voronoi Diagram</label>
                            </div>
                            <div class="flex items-center gap-2">
                                <input type="checkbox" id="show-distances" class="w-4 h-4" checked>
                                <label for="show-distances">Show Distance Circles</label>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Animation Controls -->
                    <div>
                        <h3 class="text-lg font-medium mb-2">Animation</h3>
                        <div class="flex flex-col gap-2">
                            <div>
                                <label for="animation-speed" class="block mb-1">Animation Speed:</label>
                                <input type="range" id="animation-speed" min="0.5" max="5" step="0.1" value="1" class="w-full">
                                <div class="flex justify-between text-sm">
                                    <span>Slow</span>
                                    <span id="animation-speed-value">1x</span>
                                    <span>Fast</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Status and Info -->
                    <div id="classification-result" class="p-3 bg-gray-100 dark:bg-gray-700 rounded hidden">
                        <h3 class="text-lg font-medium mb-2">Classification Result</h3>
                        <div class="space-y-2">
                            <div class="flex justify-between">
                                <span>Predicted Class:</span>
                                <span id="predicted-class" class="font-bold">-</span>
                            </div>
                            <div class="flex justify-between">
                                <span>Decision Confidence:</span>
                                <span id="decision-confidence">-</span>
                            </div>
                            <div class="flex justify-between items-center">
                                <span>Class 0 Votes:</span>
                                <div class="w-32 bg-gray-200 dark:bg-gray-600 h-4 rounded-full overflow-hidden">
                                    <div id="class-0-votes" class="bg-red-500 h-full" style="width: 0%"></div>
                                </div>
                                <span id="class-0-vote-count">0</span>
                            </div>
                            <div class="flex justify-between items-center">
                                <span>Class 1 Votes:</span>
                                <div class="w-32 bg-gray-200 dark:bg-gray-600 h-4 rounded-full overflow-hidden">
                                    <div id="class-1-votes" class="bg-blue-500 h-full" style="width: 0%"></div>
                                </div>
                                <span id="class-1-vote-count">0</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Explanation Section -->
        <div class="mt-6 bg-white dark:bg-gray-800 rounded-lg shadow-lg p-4">
            <h2 class="text-xl font-semibold mb-4 text-[#3498db] dark:text-[#3498db]">How K-Nearest Neighbors Works</h2>
            <div class="space-y-3 text-sm md:text-base">
                <p><strong>Step 1: Proximity Calculation</strong> - For a new data point, calculate its distance to all training points using the chosen distance metric (Euclidean, Manhattan, etc.).</p>
                <p><strong>Step 2: Neighbor Selection</strong> - Select the K training points closest to the new data point as its "neighbors".</p>
                <p><strong>Step 3: Voting</strong> - The new point is classified based on the majority class among its K neighbors. This can be uniform (each neighbor has equal vote) or weighted by distance (closer neighbors have more influence).</p>
                <p><strong>Key Parameters:</strong></p>
                <ul class="list-disc ml-6">
                    <li><strong>K value:</strong> The number of neighbors to consider. Larger values smooth decision boundaries and reduce noise sensitivity, but may miss local patterns.</li>
                    <li><strong>Distance metric:</strong> How similarity between points is measured. Common options include Euclidean (straight-line), Manhattan (city block), and Chebyshev (maximum coordinate difference).</li>
                    <li><strong>Weighting:</strong> Whether all neighbors have equal influence (uniform) or closer neighbors matter more (distance-weighted).</li>
                </ul>
                <p>KNN is a "lazy learning" algorithm - it doesn't build a model during training, but stores all training examples and classifies new points at prediction time.</p>
            </div>
        </div>
    </div>

    <script>
        // Initialize dark mode based on user preference
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.body.classList.add('dark');
        }
        
        // DOM elements
        const svg = document.getElementById('visualization');
        const generateDataBtn = document.getElementById('generate-data');
        const numPointsInput = document.getElementById('num-points');
        const dataPatternSelect = document.getElementById('data-pattern');
        const noiseLevelInput = document.getElementById('noise-level');
        const noiseValueDisplay = document.getElementById('noise-value');
        const kValueInput = document.getElementById('k-value');
        const kValueDisplay = document.getElementById('k-value-display');
        const distanceMetricSelect = document.getElementById('distance-metric');
        const weightTypeSelect = document.getElementById('weight-type');
        const enableTestPointCheckbox = document.getElementById('enable-test-point');
        const testPointControls = document.getElementById('test-point-controls');
        const testPointXInput = document.getElementById('test-point-x');
        const testPointYInput = document.getElementById('test-point-y');
        const testPointXValue = document.getElementById('test-point-x-value');
        const testPointYValue = document.getElementById('test-point-y-value');
        const classifyBtn = document.getElementById('classify-btn');
        const showDecisionBoundaryCheckbox = document.getElementById('show-decision-boundary');
        const showVoronoiCheckbox = document.getElementById('show-voronoi');
        const showDistancesCheckbox = document.getElementById('show-distances');
        const animationSpeedInput = document.getElementById('animation-speed');
        const animationSpeedValue = document.getElementById('animation-speed-value');
        const classificationResult = document.getElementById('classification-result');
        const predictedClassDisplay = document.getElementById('predicted-class');
        const decisionConfidenceDisplay = document.getElementById('decision-confidence');
        const class0Votes = document.getElementById('class-0-votes');
        const class1Votes = document.getElementById('class-1-votes');
        const class0VoteCount = document.getElementById('class-0-vote-count');
        const class1VoteCount = document.getElementById('class-1-vote-count');
        
        // SVG namespace
        const svgNS = "http://www.w3.org/2000/svg";
        
        // Visualization constants
        const WIDTH = 1000;
        const HEIGHT = 600;
        const MARGIN = 50;
        const PLOT_WIDTH = WIDTH - 2 * MARGIN;
        const PLOT_HEIGHT = HEIGHT - 2 * MARGIN;
        
        // Data visualization constants
        const DATA_HEIGHT = HEIGHT * 0.55 - MARGIN * 1.5;
        const DATA_WIDTH = WIDTH - MARGIN * 2;
        const DATA_X = MARGIN;
        const DATA_Y = MARGIN;
        
        // KNN visualization constants
        const KNN_HEIGHT = HEIGHT * 0.45 - MARGIN * 1.5;
        const KNN_WIDTH = WIDTH - MARGIN * 2;
        const KNN_X = MARGIN;
        const KNN_Y = DATA_Y + DATA_HEIGHT + MARGIN;
        
        // Colors
        const CLASS_0_COLOR = '#EF4444'; // Red
        const CLASS_1_COLOR = '#3B82F6'; // Blue
        const TEST_POINT_COLOR = '#5D5CDE'; // Purple
        const NEIGHBOR_HIGHLIGHT_COLOR = '#FCD34D'; // Yellow
        const DISTANCE_COLOR = '#5D5CDE'; // Purple with opacity
        const GRID_COLOR_LIGHT = '#E2E8F0';
        const GRID_COLOR_DARK = '#374151';
        const TEXT_COLOR_LIGHT = '#1F2937';
        const TEXT_COLOR_DARK = '#D1D5DB';
        
        // Data and model parameters
        let data = [];
        let testPoint = { x1: 5, x2: 5 };
        let kValue = 5;
        let distanceMetric = 'euclidean';
        let weightType = 'uniform';
        let noiseLevel = 0.1;
        let animationSpeed = 1;
        let nearestNeighbors = [];
        let distancesCalculated = false;
        let animationInProgress = false;
        let classVotes = { 0: 0, 1: 0 };
        
        // Initialize the SVG elements
        function initSVG() {
            // Clear existing SVG
            svg.innerHTML = '';
            
            // Add background
            const background = document.createElementNS(svgNS, 'rect');
            background.setAttribute('width', WIDTH);
            background.setAttribute('height', HEIGHT);
            background.setAttribute('fill', document.body.classList.contains('dark') ? '#1F2937' : '#f8fafc');
            svg.appendChild(background);
            
            // Add separator between data and KNN visualizations
            const separator = document.createElementNS(svgNS, 'line');
            separator.setAttribute('x1', MARGIN);
            separator.setAttribute('y1', KNN_Y - MARGIN/2);
            separator.setAttribute('x2', WIDTH - MARGIN);
            separator.setAttribute('y2', KNN_Y - MARGIN/2);
            separator.setAttribute('stroke', document.body.classList.contains('dark') ? GRID_COLOR_DARK : GRID_COLOR_LIGHT);
            separator.setAttribute('stroke-width', '2');
            separator.setAttribute('stroke-dasharray', '5,5');
            svg.appendChild(separator);
            
            // Add grid lines for data visualization
            for (let i = 0; i <= 10; i++) {
                const xPos = DATA_X + (DATA_WIDTH / 10) * i;
                const yPos = DATA_Y + (DATA_HEIGHT / 10) * i;
                
                // Vertical grid line
                const vLine = document.createElementNS(svgNS, 'line');
                vLine.setAttribute('x1', xPos);
                vLine.setAttribute('y1', DATA_Y);
                vLine.setAttribute('x2', xPos);
                vLine.setAttribute('y2', DATA_Y + DATA_HEIGHT);
                vLine.setAttribute('stroke', document.body.classList.contains('dark') ? GRID_COLOR_DARK : GRID_COLOR_LIGHT);
                vLine.setAttribute('stroke-width', '1');
                svg.appendChild(vLine);
                
                // Horizontal grid line
                const hLine = document.createElementNS(svgNS, 'line');
                hLine.setAttribute('x1', DATA_X);
                hLine.setAttribute('y1', yPos);
                hLine.setAttribute('x2', DATA_X + DATA_WIDTH);
                hLine.setAttribute('y2', yPos);
                hLine.setAttribute('stroke', document.body.classList.contains('dark') ? GRID_COLOR_DARK : GRID_COLOR_LIGHT);
                hLine.setAttribute('stroke-width', '1');
                svg.appendChild(hLine);
            }
            
            // Add axes for data visualization
            const xAxis = document.createElementNS(svgNS, 'line');
            xAxis.setAttribute('x1', DATA_X);
            xAxis.setAttribute('y1', DATA_Y + DATA_HEIGHT);
            xAxis.setAttribute('x2', DATA_X + DATA_WIDTH);
            xAxis.setAttribute('y2', DATA_Y + DATA_HEIGHT);
            xAxis.setAttribute('stroke', document.body.classList.contains('dark') ? TEXT_COLOR_DARK : TEXT_COLOR_LIGHT);
            xAxis.setAttribute('stroke-width', '2');
            svg.appendChild(xAxis);
            
            const yAxis = document.createElementNS(svgNS, 'line');
            yAxis.setAttribute('x1', DATA_X);
            yAxis.setAttribute('y1', DATA_Y);
            yAxis.setAttribute('x2', DATA_X);
            yAxis.setAttribute('y2', DATA_Y + DATA_HEIGHT);
            yAxis.setAttribute('stroke', document.body.classList.contains('dark') ? TEXT_COLOR_DARK : TEXT_COLOR_LIGHT);
            yAxis.setAttribute('stroke-width', '2');
            svg.appendChild(yAxis);
            
            // Add axis labels for data visualization
            const xLabel = document.createElementNS(svgNS, 'text');
            xLabel.setAttribute('x', DATA_X + DATA_WIDTH / 2);
            xLabel.setAttribute('y', DATA_Y + DATA_HEIGHT + 30);
            xLabel.setAttribute('text-anchor', 'middle');
            xLabel.setAttribute('fill', document.body.classList.contains('dark') ? TEXT_COLOR_DARK : TEXT_COLOR_LIGHT);
            xLabel.textContent = 'Feature X₁';
            svg.appendChild(xLabel);
            
            const yLabel = document.createElementNS(svgNS, 'text');
            yLabel.setAttribute('x', DATA_X - 30);
            yLabel.setAttribute('y', DATA_Y + DATA_HEIGHT / 2);
            yLabel.setAttribute('text-anchor', 'middle');
            yLabel.setAttribute('transform', `rotate(-90, ${DATA_X - 30}, ${DATA_Y + DATA_HEIGHT / 2})`);
            yLabel.setAttribute('fill', document.body.classList.contains('dark') ? TEXT_COLOR_DARK : TEXT_COLOR_LIGHT);
            yLabel.textContent = 'Feature X₂';
            svg.appendChild(yLabel);
            
            // Add titles for data and KNN sections
            const dataTitle = document.createElementNS(svgNS, 'text');
            dataTitle.setAttribute('x', DATA_X + DATA_WIDTH / 2);
            dataTitle.setAttribute('y', DATA_Y - 20);
            dataTitle.setAttribute('text-anchor', 'middle');
            dataTitle.setAttribute('fill', document.body.classList.contains('dark') ? TEXT_COLOR_DARK : TEXT_COLOR_LIGHT);
            dataTitle.setAttribute('font-weight', 'bold');
            dataTitle.textContent = 'Data & Decision Boundary';
            svg.appendChild(dataTitle);
            
            const knnTitle = document.createElementNS(svgNS, 'text');
            knnTitle.setAttribute('x', KNN_X + KNN_WIDTH / 2);
            knnTitle.setAttribute('y', KNN_Y + 10);
            knnTitle.setAttribute('text-anchor', 'middle');
            knnTitle.setAttribute('fill', document.body.classList.contains('dark') ? TEXT_COLOR_DARK : TEXT_COLOR_LIGHT);
            knnTitle.setAttribute('font-weight', 'bold');
            knnTitle.textContent = 'K-Nearest Neighbors Voting Visualization';
            svg.appendChild(knnTitle);
        }
        
        // Generate synthetic data for classification
        function generateData() {
            const numPoints = parseInt(numPointsInput.value);
            const pattern = dataPatternSelect.value;
            noiseLevel = parseFloat(noiseLevelInput.value);
            data = [];
            
            // Define variables that might be used across different pattern cases
            let x1, x2, y;
            let angle, r, radius;
            
            for (let i = 0; i < numPoints; i++) {
                // Generate different data patterns
                switch (pattern) {
                    case 'blobs':
                        // Simple blobs pattern
                        if (Math.random() < 0.5) {
                            x1 = Math.random() * 3 + 2;
                            x2 = Math.random() * 3 + 2;
                            y = 0;
                        } else {
                            x1 = Math.random() * 3 + 6;
                            x2 = Math.random() * 3 + 6;
                            y = 1;
                        }
                        break;
                        
                    case 'circle':
                        // Circular pattern (points inside a circle are one class)
                        x1 = Math.random() * 10;
                        x2 = Math.random() * 10;
                        const centerX = 5;
                        const centerY = 5;
                        radius = 3;
                        const distance = Math.sqrt(Math.pow(x1 - centerX, 2) + Math.pow(x2 - centerY, 2));
                        y = distance < radius ? 1 : 0;
                        break;
                        
                    case 'moons':
                        // Two moons pattern
                        if (Math.random() < 0.5) {
                            // First moon
                            angle = Math.random() * Math.PI;
                            r = 3;
                            x1 = 5 + r * Math.cos(angle);
                            x2 = 5 + r * Math.sin(angle);
                            y = 1;
                        } else {
                            // Second moon
                            angle = Math.random() * Math.PI;
                            r = 3;
                            x1 = 5 - r * Math.cos(angle);
                            x2 = 5 - r * Math.sin(angle) + 3;
                            y = 0;
                        }
                        
                        // Ensure x1 and x2 are within range
                        x1 = Math.max(0, Math.min(10, x1));
                        x2 = Math.max(0, Math.min(10, x2));
                        break;
                        
                    case 'spiral':
                        // Spiral pattern
                        const turns = 2;
                        const start_radius = 0.5;
                        const end_radius = 4;
                        
                        // Determine if we're generating class 0 or class 1
                        const class_type = Math.random() < 0.5 ? 0 : 1;
                        
                        // Generate angle (add offset for class 1)
                        const angle_offset = class_type * Math.PI / turns;
                        angle = (Math.random() * turns * Math.PI) + angle_offset;
                        
                        // Calculate radius based on angle
                        const radius_factor = Math.random() * 0.5 + 0.5; // Between 0.5 and 1.0
                        r = start_radius + (end_radius - start_radius) * (angle / (turns * Math.PI)) * radius_factor;
                        
                        // Convert to Cartesian coordinates
                        x1 = 5 + r * Math.cos(angle);
                        x2 = 5 + r * Math.sin(angle);
                        y = class_type;
                        
                        // Ensure x1 and x2 are within range
                        x1 = Math.max(0, Math.min(10, x1));
                        x2 = Math.max(0, Math.min(10, x2));
                        break;
                        
                    default:
                        // Default to blobs if unknown pattern
                        if (Math.random() < 0.5) {
                            x1 = Math.random() * 3 + 2;
                            x2 = Math.random() * 3 + 2;
                            y = 0;
                        } else {
                            x1 = Math.random() * 3 + 6;
                            x2 = Math.random() * 3 + 6;
                            y = 1;
                        }
                }
                
                // Add noise (flip class labels randomly based on noise level)
                if (Math.random() < noiseLevel) {
                    y = 1 - y; // Flip 0 to 1 or 1 to 0
                }
                
                data.push({ x1, x2, y });
            }
            
            // Reset visualization
            resetVisualization();
            visualizeData();
            
            // Reset test point
            if (enableTestPointCheckbox.checked) {
                visualizeTestPoint();
            }
            
            // Show decision boundary if enabled
            if (showDecisionBoundaryCheckbox.checked) {
                visualizeDecisionBoundary();
            }
        }
        
        // Reset the visualization state
        function resetVisualization() {
            // Reset nearest neighbors
            nearestNeighbors = [];
            distancesCalculated = false;
            
            // Reset animation state
            animationInProgress = false;
            
            // Hide classification result
            classificationResult.classList.add('hidden');
            
            // Clear visualization elements
            clearDecisionBoundary();
            clearDistances();
            clearVoronoi();
            clearTestPoint();
            clearKNNVisualization();
            
            // Reset class votes
            classVotes = { 0: 0, 1: 0 };
        }
        
        // Map data coordinates to SVG coordinates in the data visualization area
        function mapDataX(x) {
            return DATA_X + (x / 10) * DATA_WIDTH;
        }
        
        function mapDataY(y) {
            return DATA_Y + DATA_HEIGHT - (y / 10) * DATA_HEIGHT;
        }
        
        // Visualize the data points
        function visualizeData() {
            // Remove existing data points
            const existingPoints = svg.querySelectorAll('.data-point');
            existingPoints.forEach(point => point.remove());
            
            // Add new data points
            data.forEach((point, index) => {
                const circle = document.createElementNS(svgNS, 'circle');
                circle.setAttribute('cx', mapDataX(point.x1));
                circle.setAttribute('cy', mapDataY(point.x2));
                circle.setAttribute('r', '6');
                circle.setAttribute('fill', point.y === 1 ? CLASS_1_COLOR : CLASS_0_COLOR);
                circle.setAttribute('stroke', document.body.classList.contains('dark') ? '#F3F4F6' : '#1F2937');
                circle.setAttribute('stroke-width', '1');
                circle.setAttribute('class', 'data-point');
                circle.setAttribute('data-index', index);
                
                // Add animation with anime.js
                circle.style.opacity = '0';
                circle.style.transform = 'scale(0)';
                
                svg.appendChild(circle);
            });
            
            // Animate the appearance of data points
            anime({
                targets: '.data-point',
                opacity: 1,
                scale: 1,
                delay: anime.stagger(20),
                easing: 'easeOutElastic(1, .5)',
                duration: 1500
            });
        }
        
        // Clear decision boundary
        function clearDecisionBoundary() {
            const existingBoundary = svg.querySelector('.decision-boundary-group');
            if (existingBoundary) {
                existingBoundary.remove();
            }
        }
        
        // Clear distance circles
        function clearDistances() {
            const existingDistances = svg.querySelectorAll('.distance-circle');
            existingDistances.forEach(circle => circle.remove());
        }
        
        // Clear Voronoi diagram
        function clearVoronoi() {
            const existingVoronoi = svg.querySelector('.voronoi-group');
            if (existingVoronoi) {
                existingVoronoi.remove();
            }
        }
        
        // Clear test point
        function clearTestPoint() {
            const existingTestPoint = svg.querySelector('.test-point');
            if (existingTestPoint) {
                existingTestPoint.remove();
            }
        }
        
        // Clear KNN visualization
        function clearKNNVisualization() {
            const existingKNN = svg.querySelectorAll('.knn-element');
            existingKNN.forEach(el => el.remove());
        }
        
        // Visualize the decision boundary using a grid of KNN predictions
        function visualizeDecisionBoundary() {
            clearDecisionBoundary();
            
            // Create a group for the decision boundary
            const boundaryGroup = document.createElementNS(svgNS, 'g');
            boundaryGroup.setAttribute('class', 'decision-boundary-group');
            
            // Generate a grid of predictions
            const gridSize = 40; // 40x40 grid
            const cellSize = 10 / gridSize;
            
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    const x1 = i * cellSize;
                    const x2 = j * cellSize;
                    
                    // Get KNN prediction for this grid point
                    const prediction = predictKNN({ x1, x2 });
                    
                    // Create grid cell
                    const cell = document.createElementNS(svgNS, 'rect');
                    cell.setAttribute('x', mapDataX(x1));
                    cell.setAttribute('y', mapDataY(x2 + cellSize));
                    cell.setAttribute('width', DATA_WIDTH / gridSize);
                    cell.setAttribute('height', DATA_HEIGHT / gridSize);
                    
                    // Set color based on prediction
                    const color = prediction.label === 1 ? CLASS_1_COLOR : CLASS_0_COLOR;
                    const opacity = 0.1 + 0.4 * prediction.confidence; // Opacity based on confidence
                    
                    cell.setAttribute('fill', color);
                    cell.setAttribute('opacity', opacity);
                    cell.setAttribute('class', 'decision-boundary-cell');
                    
                    boundaryGroup.appendChild(cell);
                }
            }
            
            // Insert boundary before data points so points are visible on top
            if (svg.querySelector('.data-point')) {
                svg.insertBefore(boundaryGroup, svg.querySelector('.data-point'));
            } else {
                svg.appendChild(boundaryGroup);
            }
        }
        
        // Visualize Voronoi diagram
        function visualizeVoronoi() {
            clearVoronoi();
            
            // Basic implementation of Voronoi cells using nearest neighbor for each grid point
            // For a production app, we would use a proper Voronoi library
            const voronoiGroup = document.createElementNS(svgNS, 'g');
            voronoiGroup.setAttribute('class', 'voronoi-group');
            
            // Generate a grid of points
            const gridSize = 100; // 100x100 grid
            const cellSize = 10 / gridSize;
            
            // Map each grid point to nearest training point
            const voronoiMap = new Map(); // Maps training point index to array of grid coords
            
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    const x1 = i * cellSize;
                    const x2 = j * cellSize;
                    
                    // Find nearest training point
                    let minDist = Infinity;
                    let nearestIndex = -1;
                    
                    for (let k = 0; k < data.length; k++) {
                        const dist = calculateDistance(
                            { x1, x2 },
                            { x1: data[k].x1, x2: data[k].x2 },
                            'euclidean'
                        );
                        
                        if (dist < minDist) {
                            minDist = dist;
                            nearestIndex = k;
                        }
                    }
                    
                    // Add to voronoi map
                    if (!voronoiMap.has(nearestIndex)) {
                        voronoiMap.set(nearestIndex, []);
                    }
                    voronoiMap.get(nearestIndex).push({ x1, x2 });
                }
            }
            
            // Create Voronoi cells
            for (const [index, points] of voronoiMap.entries()) {
                const pointClass = data[index].y;
                const color = pointClass === 1 ? CLASS_1_COLOR : CLASS_0_COLOR;
                
                // Create a group for this cell
                const cellGroup = document.createElementNS(svgNS, 'g');
                cellGroup.setAttribute('class', 'voronoi-cell');
                cellGroup.setAttribute('data-index', index);
                
                // Add points as small circles
                points.forEach(point => {
                    const circle = document.createElementNS(svgNS, 'circle');
                    circle.setAttribute('cx', mapDataX(point.x1));
                    circle.setAttribute('cy', mapDataY(point.x2));
                    circle.setAttribute('r', '1');
                    circle.setAttribute('fill', color);
                    circle.setAttribute('opacity', '0.3');
                    cellGroup.appendChild(circle);
                });
                
                voronoiGroup.appendChild(cellGroup);
            }
            
            // Insert Voronoi before data points
            if (svg.querySelector('.data-point')) {
                svg.insertBefore(voronoiGroup, svg.querySelector('.data-point'));
            } else {
                svg.appendChild(voronoiGroup);
            }
        }
        
        // Visualize test point
        function visualizeTestPoint() {
            clearTestPoint();
            
            // Create test point
            const testPointCircle = document.createElementNS(svgNS, 'circle');
            testPointCircle.setAttribute('cx', mapDataX(testPoint.x1));
            testPointCircle.setAttribute('cy', mapDataY(testPoint.x2));
            testPointCircle.setAttribute('r', '8');
            testPointCircle.setAttribute('fill', TEST_POINT_COLOR);
            testPointCircle.setAttribute('stroke', '#FFFFFF');
            testPointCircle.setAttribute('stroke-width', '2');
            testPointCircle.setAttribute('class', 'test-point');
            
            // Add a pulse animation to draw attention to the test point
            const animation = document.createElementNS(svgNS, 'animate');
            animation.setAttribute('attributeName', 'r');
            animation.setAttribute('values', '8;12;8');
            animation.setAttribute('dur', '2s');
            animation.setAttribute('repeatCount', '1');
            testPointCircle.appendChild(animation);
            
            svg.appendChild(testPointCircle);
        }
        
        // Calculate distance between two points
        function calculateDistance(pointA, pointB, metric) {
            switch (metric) {
                case 'euclidean':
                    return Math.sqrt(
                        Math.pow(pointA.x1 - pointB.x1, 2) + 
                        Math.pow(pointA.x2 - pointB.x2, 2)
                    );
                    
                case 'manhattan':
                    return Math.abs(pointA.x1 - pointB.x1) + 
                           Math.abs(pointA.x2 - pointB.x2);
                    
                case 'chebyshev':
                    return Math.max(
                        Math.abs(pointA.x1 - pointB.x1),
                        Math.abs(pointA.x2 - pointB.x2)
                    );
                    
                default:
                    return Math.sqrt(
                        Math.pow(pointA.x1 - pointB.x1, 2) + 
                        Math.pow(pointA.x2 - pointB.x2, 2)
                    );
            }
        }
        
        // Find K nearest neighbors
        function findKNearestNeighbors(point, k) {
            // Calculate distances to all training points
            const distances = data.map((dataPoint, index) => ({
                index,
                distance: calculateDistance(point, dataPoint, distanceMetric),
                class: dataPoint.y
            }));
            
            // Sort by distance
            distances.sort((a, b) => a.distance - b.distance);
            
            // Return k nearest
            return distances.slice(0, k);
        }
        
        // Predict class using KNN
        function predictKNN(point) {
            // Find k nearest neighbors
            const neighbors = findKNearestNeighbors(point, kValue);
            
            // Initialize votes
            const votes = { 0: 0, 1: 0 };
            let totalWeight = 0;
            
            // Calculate votes based on weighting scheme
            if (weightType === 'uniform') {
                // Each neighbor gets equal vote
                neighbors.forEach(neighbor => {
                    votes[neighbor.class] += 1;
                    totalWeight += 1;
                });
            } else if (weightType === 'distance') {
                // Weight by inverse distance
                neighbors.forEach(neighbor => {
                    // Avoid division by zero
                    const weight = neighbor.distance === 0 ? 1000 : 1 / neighbor.distance;
                    votes[neighbor.class] += weight;
                    totalWeight += weight;
                });
            }
            
            // Determine majority class
            const label = votes[1] > votes[0] ? 1 : 0;
            
            // Calculate confidence
            const confidence = Math.max(votes[0], votes[1]) / totalWeight;
            
            return { label, confidence, votes, totalWeight };
        }
        
        // Visualize distances from test point
        function visualizeDistances() {
            clearDistances();
            
            // Find distances to all training points
            const distances = data.map((dataPoint, index) => ({
                index,
                distance: calculateDistance(testPoint, dataPoint, distanceMetric),
                class: dataPoint.y
            }));
            
            // Sort by distance
            distances.sort((a, b) => a.distance - b.distance);
            
            // Scale distances for visualization
            // Get the maximum distance for normalization
            const maxDistance = Math.max(...distances.map(d => d.distance));
            
            // Draw distance circles for the K nearest neighbors
            const kNearest = distances.slice(0, kValue);
            
            kNearest.forEach((neighbor, i) => {
                // Draw distance circle
                const distanceCircle = document.createElementNS(svgNS, 'circle');
                distanceCircle.setAttribute('cx', mapDataX(testPoint.x1));
                distanceCircle.setAttribute('cy', mapDataY(testPoint.x2));
                distanceCircle.setAttribute('r', neighbor.distance * DATA_WIDTH / 10);
                distanceCircle.setAttribute('fill', 'none');
                distanceCircle.setAttribute('stroke', DISTANCE_COLOR);
                distanceCircle.setAttribute('stroke-width', '1.5');
                distanceCircle.setAttribute('stroke-dasharray', '5,5');
                distanceCircle.setAttribute('class', 'distance-circle');
                distanceCircle.setAttribute('data-index', neighbor.index);
                
                // Add animation with anime.js
                distanceCircle.style.opacity = '0';
                
                svg.appendChild(distanceCircle);
            });
            
            // Highlight nearest points
            const dataPoints = svg.querySelectorAll('.data-point');
            dataPoints.forEach(point => {
                const index = parseInt(point.getAttribute('data-index'));
                
                // Check if this point is one of the K nearest neighbors
                const isNeighbor = kNearest.some(n => n.index === index);
                
                if (isNeighbor) {
                    point.setAttribute('stroke', NEIGHBOR_HIGHLIGHT_COLOR);
                    point.setAttribute('stroke-width', '3');
                    point.setAttribute('r', '8');
                } else {
                    point.setAttribute('stroke', document.body.classList.contains('dark') ? '#F3F4F6' : '#1F2937');
                    point.setAttribute('stroke-width', '1');
                    point.setAttribute('r', '6');
                }
            });
            
            // Animate distance circles
            anime({
                targets: '.distance-circle',
                opacity: [0, 0.6],
                delay: anime.stagger(500),
                easing: 'easeOutSine',
                duration: 1000
            });
            
            // Store nearest neighbors for later use
            nearestNeighbors = kNearest;
            distancesCalculated = true;
            
            return kNearest;
        }
        
        // Visualize KNN voting process
        function visualizeKNNVoting(neighbors) {
            clearKNNVisualization();
            
            // Create group for KNN visualization
            const knnGroup = document.createElementNS(svgNS, 'g');
            knnGroup.setAttribute('class', 'knn-group');
            
            // Calculate total width and spacing
            const totalWidth = KNN_WIDTH * 0.9;
            const elemWidth = totalWidth / neighbors.length;
            const startX = KNN_X + (KNN_WIDTH - totalWidth) / 2;
            
            // Reset votes
            classVotes = { 0: 0, 1: 0 };
            let totalWeight = 0;
            
            // Create voting visualization
            const votingElements = [];
            
            // Calculate weights based on weighting scheme
            const weights = neighbors.map(neighbor => {
                if (weightType === 'uniform') {
                    return 1;
                } else {
                    // Weight by inverse distance
                    return neighbor.distance === 0 ? 1000 : 1 / neighbor.distance;
                }
            });
            
            // Calculate total weight for normalization
            const totalWeightSum = weights.reduce((sum, w) => sum + w, 0);
            
            // Create representation for each neighbor
            neighbors.forEach((neighbor, i) => {
                const x = startX + i * elemWidth;
                const y = KNN_Y + KNN_HEIGHT / 2;
                
                // Calculate normalized weight
                const weight = weights[i] / totalWeightSum;
                
                // Add to class votes
                classVotes[neighbor.class] += weight;
                totalWeight += weight;
                
                // Create neighbor element
                const neighborGroup = document.createElementNS(svgNS, 'g');
                neighborGroup.setAttribute('class', 'knn-element neighbor-group');
                neighborGroup.setAttribute('data-index', neighbor.index);
                
                // Neighbor circle
                const neighborCircle = document.createElementNS(svgNS, 'circle');
                neighborCircle.setAttribute('cx', x + elemWidth / 2);
                neighborCircle.setAttribute('cy', y - 40);
                neighborCircle.setAttribute('r', 20 * (weightType === 'distance' ? Math.sqrt(weight * 3) : 1));
                neighborCircle.setAttribute('fill', neighbor.class === 1 ? CLASS_1_COLOR : CLASS_0_COLOR);
                neighborCircle.setAttribute('stroke', NEIGHBOR_HIGHLIGHT_COLOR);
                neighborCircle.setAttribute('stroke-width', '2');
                neighborGroup.appendChild(neighborCircle);
                
                // Neighbor index
                const neighborIndex = document.createElementNS(svgNS, 'text');
                neighborIndex.setAttribute('x', x + elemWidth / 2);
                neighborIndex.setAttribute('y', y - 35);
                neighborIndex.setAttribute('text-anchor', 'middle');
                neighborIndex.setAttribute('fill', '#FFFFFF');
                neighborIndex.setAttribute('font-weight', 'bold');
                neighborIndex.textContent = (i + 1).toString();
                neighborGroup.appendChild(neighborIndex);
                
                // Distance label
                const distanceLabel = document.createElementNS(svgNS, 'text');
                distanceLabel.setAttribute('x', x + elemWidth / 2);
                distanceLabel.setAttribute('y', y);
                distanceLabel.setAttribute('text-anchor', 'middle');
                distanceLabel.setAttribute('fill', document.body.classList.contains('dark') ? TEXT_COLOR_DARK : TEXT_COLOR_LIGHT);
                distanceLabel.setAttribute('font-size', '12');
                distanceLabel.textContent = `d = ${neighbor.distance.toFixed(2)}`;
                neighborGroup.appendChild(distanceLabel);
                
                // Weight label (if distance-weighted)
                if (weightType === 'distance') {
                    const weightLabel = document.createElementNS(svgNS, 'text');
                    weightLabel.setAttribute('x', x + elemWidth / 2);
                    weightLabel.setAttribute('y', y + 20);
                    weightLabel.setAttribute('text-anchor', 'middle');
                    weightLabel.setAttribute('fill', document.body.classList.contains('dark') ? TEXT_COLOR_DARK : TEXT_COLOR_LIGHT);
                    weightLabel.setAttribute('font-size', '12');
                    weightLabel.textContent = `w = ${(weight * 100).toFixed(1)}%`;
                    neighborGroup.appendChild(weightLabel);
                }
                
                // Add to visualization
                knnGroup.appendChild(neighborGroup);
                votingElements.push(neighborGroup);
            });
            
            // Add dividing line
            const divider = document.createElementNS(svgNS, 'line');
            divider.setAttribute('x1', KNN_X + KNN_WIDTH * 0.05);
            divider.setAttribute('y1', KNN_Y + KNN_HEIGHT * 0.6);
            divider.setAttribute('x2', KNN_X + KNN_WIDTH * 0.95);
            divider.setAttribute('y2', KNN_Y + KNN_HEIGHT * 0.6);
            divider.setAttribute('stroke', document.body.classList.contains('dark') ? GRID_COLOR_DARK : GRID_COLOR_LIGHT);
            divider.setAttribute('stroke-width', '2');
            divider.setAttribute('class', 'knn-element');
            knnGroup.appendChild(divider);
            
            // Add vote totals
            const voteY = KNN_Y + KNN_HEIGHT * 0.8;
            
            // Class 0 votes
            const class0Text = document.createElementNS(svgNS, 'text');
            class0Text.setAttribute('x', KNN_X + KNN_WIDTH * 0.25);
            class0Text.setAttribute('y', voteY);
            class0Text.setAttribute('text-anchor', 'middle');
            class0Text.setAttribute('fill', CLASS_0_COLOR);
            class0Text.setAttribute('font-weight', 'bold');
            class0Text.setAttribute('class', 'knn-element');
            class0Text.textContent = `Class 0 Votes: ${(classVotes[0] * 100).toFixed(1)}%`;
            knnGroup.appendChild(class0Text);
            
            // Class 1 votes
            const class1Text = document.createElementNS(svgNS, 'text');
            class1Text.setAttribute('x', KNN_X + KNN_WIDTH * 0.75);
            class1Text.setAttribute('y', voteY);
            class1Text.setAttribute('text-anchor', 'middle');
            class1Text.setAttribute('fill', CLASS_1_COLOR);
            class1Text.setAttribute('font-weight', 'bold');
            class1Text.setAttribute('class', 'knn-element');
            class1Text.textContent = `Class 1 Votes: ${(classVotes[1] * 100).toFixed(1)}%`;
            knnGroup.appendChild(class1Text);
            
            // Prediction result
            const predictedClass = classVotes[1] > classVotes[0] ? 1 : 0;
            const predictedColor = predictedClass === 1 ? CLASS_1_COLOR : CLASS_0_COLOR;
            const confidence = Math.max(classVotes[0], classVotes[1]);
            
            const resultText = document.createElementNS(svgNS, 'text');
            resultText.setAttribute('x', KNN_X + KNN_WIDTH / 2);
            resultText.setAttribute('y', KNN_Y + KNN_HEIGHT * 0.95);
            resultText.setAttribute('text-anchor', 'middle');
            resultText.setAttribute('fill', predictedColor);
            resultText.setAttribute('font-weight', 'bold');
            resultText.setAttribute('class', 'knn-element');
            resultText.textContent = `Prediction: Class ${predictedClass} (${(confidence * 100).toFixed(1)}% confidence)`;
            knnGroup.appendChild(resultText);
            
            // Add to SVG
            svg.appendChild(knnGroup);
            
            // Animate voting elements
            anime({
                targets: '.neighbor-group',
                opacity: [0, 1],
                translateY: [20, 0],
                delay: anime.stagger(200),
                easing: 'easeOutQuad',
                duration: 1000
            });
            
            // Update result panel
            updateResultPanel(predictedClass, confidence);
            
            return { predictedClass, confidence };
        }
        
        // Update classification result panel
        function updateResultPanel(predictedClass, confidence) {
            classificationResult.classList.remove('hidden');
            
            predictedClassDisplay.textContent = `Class ${predictedClass}`;
            predictedClassDisplay.style.color = predictedClass === 1 ? CLASS_1_COLOR : CLASS_0_COLOR;
            
            decisionConfidenceDisplay.textContent = `${(confidence * 100).toFixed(1)}%`;
            
            // Update vote bars
            class0Votes.style.width = `${classVotes[0] * 100}%`;
            class1Votes.style.width = `${classVotes[1] * 100}%`;
            
            // Update vote counts
            class0VoteCount.textContent = (classVotes[0] * 100).toFixed(1) + '%';
            class1VoteCount.textContent = (classVotes[1] * 100).toFixed(1) + '%';
        }
        
        // Classify test point with animation
        async function classifyTestPointWithAnimation() {
            if (animationInProgress) return;
            animationInProgress = true;
            
            // Reset visualization
            clearDistances();
            clearKNNVisualization();
            
            // Find nearest neighbors
            const neighbors = visualizeDistances();
            
            // Animate the distance circles appearing
            await new Promise(resolve => {
                setTimeout(resolve, 1000 * kValue / animationSpeed);
            });
            
            // Visualize KNN voting
            visualizeKNNVoting(neighbors);
            
            animationInProgress = false;
        }
        
        // Event listeners
        generateDataBtn.addEventListener('click', generateData);
        
        noiseLevelInput.addEventListener('input', () => {
            noiseLevel = parseFloat(noiseLevelInput.value);
            noiseValueDisplay.textContent = noiseLevel.toFixed(2);
        });
        
        kValueInput.addEventListener('input', () => {
            kValue = parseInt(kValueInput.value);
            kValueDisplay.textContent = kValue;
            
            // Update visualization if we already have data and a test point
            if (data.length > 0 && enableTestPointCheckbox.checked && distancesCalculated) {
                visualizeDistances();
                
                if (nearestNeighbors.length > 0) {
                    visualizeKNNVoting(nearestNeighbors);
                }
            }
            
            // Update decision boundary if enabled
            if (showDecisionBoundaryCheckbox.checked) {
                visualizeDecisionBoundary();
            }
        });
        
        distanceMetricSelect.addEventListener('change', () => {
            distanceMetric = distanceMetricSelect.value;
            
            // Update visualization if we already have data and a test point
            if (data.length > 0 && enableTestPointCheckbox.checked && distancesCalculated) {
                visualizeDistances();
                
                if (nearestNeighbors.length > 0) {
                    visualizeKNNVoting(nearestNeighbors);
                }
            }
            
            // Update decision boundary if enabled
            if (showDecisionBoundaryCheckbox.checked) {
                visualizeDecisionBoundary();
            }
        });
        
        weightTypeSelect.addEventListener('change', () => {
            weightType = weightTypeSelect.value;
            
            // Update visualization if we already have data and a test point
            if (data.length > 0 && enableTestPointCheckbox.checked && distancesCalculated) {
                if (nearestNeighbors.length > 0) {
                    visualizeKNNVoting(nearestNeighbors);
                }
            }
            
            // Update decision boundary if enabled
            if (showDecisionBoundaryCheckbox.checked) {
                visualizeDecisionBoundary();
            }
        });
        
        enableTestPointCheckbox.addEventListener('change', () => {
            testPointControls.style.display = enableTestPointCheckbox.checked ? 'block' : 'none';
            
            if (enableTestPointCheckbox.checked) {
                visualizeTestPoint();
            } else {
                clearTestPoint();
                clearDistances();
                clearKNNVisualization();
                classificationResult.classList.add('hidden');
            }
        });
        
        testPointXInput.addEventListener('input', () => {
            testPoint.x1 = parseFloat(testPointXInput.value);
            testPointXValue.textContent = testPoint.x1.toFixed(1);
            
            if (enableTestPointCheckbox.checked) {
                visualizeTestPoint();
            }
            
            // Reset distances and voting
            clearDistances();
            clearKNNVisualization();
            distancesCalculated = false;
        });
        
        testPointYInput.addEventListener('input', () => {
            testPoint.x2 = parseFloat(testPointYInput.value);
            testPointYValue.textContent = testPoint.x2.toFixed(1);
            
            if (enableTestPointCheckbox.checked) {
                visualizeTestPoint();
            }
            
            // Reset distances and voting
            clearDistances();
            clearKNNVisualization();
            distancesCalculated = false;
        });
        
        classifyBtn.addEventListener('click', () => {
            if (data.length === 0) {
                alert('Please generate data first.');
                return;
            }
            
            classifyTestPointWithAnimation();
        });
        
        showDecisionBoundaryCheckbox.addEventListener('change', () => {
            if (showDecisionBoundaryCheckbox.checked) {
                visualizeDecisionBoundary();
            } else {
                clearDecisionBoundary();
            }
        });
        
        showVoronoiCheckbox.addEventListener('change', () => {
            if (showVoronoiCheckbox.checked) {
                visualizeVoronoi();
            } else {
                clearVoronoi();
            }
        });
        
        showDistancesCheckbox.addEventListener('change', () => {
            if (showDistancesCheckbox.checked && distancesCalculated) {
                visualizeDistances();
            } else {
                clearDistances();
            }
        });
        
        animationSpeedInput.addEventListener('input', () => {
            animationSpeed = parseFloat(animationSpeedInput.value);
            animationSpeedValue.textContent = `${animationSpeed.toFixed(1)}x`;
        });
        
        // Initialize the application
        initSVG();
        generateData();
    </script>
</body>
</html>