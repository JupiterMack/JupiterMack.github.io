<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive SVM Visualization</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-white dark:bg-gray-900 text-gray-900 dark:text-gray-100 transition-colors duration-200">
    <body class="bg-white dark:bg-gray-900 text-gray-900 dark:text-gray-100 transition-colors duration-200">
        <a href="../algorithms.html" style="position: fixed; top: 20px; left: 20px; z-index: 1000; background: #bbbbbb; color: #000000; border: 1px solid rgba(52, 152, 219, 0.2); border-radius: 5px; padding: 8px 16px; font-family: 'Roboto Mono', monospace; font-size: 14px; font-weight: 500; cursor: pointer; text-decoration: none; display: flex; align-items: center; gap: 8px; transition: all 0.3s ease;">
            <span style="font-size: 18px;">‚Üê</span> Return to Algorithms
        </a>
    <div class="container mx-auto px-4 py-8">
        <h1 class="text-3xl font-bold mb-6 text-center text-[#3498DB] dark:text-[#3498DB]">Support Vector Machine Visualization</h1>
        
        <div class="flex flex-col lg:flex-row gap-6">
            <!-- SVG Visualization Container -->
            <div class="w-full lg:w-2/3 bg-white dark:bg-gray-800 rounded-lg shadow-lg p-4">
                <div class="w-full h-[600px] relative" id="visualization-container">
                    <svg id="visualization" class="w-full h-full" viewBox="0 0 1000 600"></svg>
                </div>
                <div class="mt-2 flex justify-between items-center text-sm">
                    <div class="flex items-center gap-2">
                        <span class="inline-block w-3 h-3 rounded-full bg-blue-500"></span>
                        <span>Class 1</span>
                    </div>
                    <div class="flex items-center gap-2">
                        <span class="inline-block w-3 h-3 rounded-full bg-red-500"></span>
                        <span>Class 0</span>
                    </div>
                </div>
            </div>
            
            <!-- Controls Panel -->
            <div class="w-full lg:w-1/3 bg-white dark:bg-gray-800 rounded-lg shadow-lg p-4">
                <h2 class="text-xl font-semibold mb-4 text-[#3498db] dark:text-[#3498db]">Controls</h2>
                
                <div class="space-y-6">
                    <!-- Data Generation -->
                    <div>
                        <h3 class="text-lg font-medium mb-2">Data</h3>
                        <div class="flex flex-col gap-2">
                            <div class="flex items-center justify-between">
                                <label for="num-points" class="mr-2">Number of Points:</label>
                                <input type="number" id="num-points" min="10" max="200" value="50" class="w-20 px-2 py-1 border rounded dark:bg-gray-700 dark:border-gray-600 dark:text-white text-base">
                            </div>
                            <div class="flex items-center justify-between">
                                <label for="data-complexity" class="mr-2">Data Pattern:</label>
                                <select id="data-complexity" class="w-40 px-2 py-1 border rounded dark:bg-gray-700 dark:border-gray-600 dark:text-white text-base">
                                    <option value="linearly-separable">Linearly Separable</option>
                                    <option value="circle" selected>Circle</option>
                                    <option value="moons">Moons</option>
                                    <option value="xor">XOR</option>
                                </select>
                            </div>
                            <div class="flex items-center justify-between">
                                <label for="noise-level" class="mr-2">Noise Level:</label>
                                <input type="range" id="noise-level" min="0" max="1" step="0.05" value="0.1" class="w-40">
                                <span id="noise-value" class="text-sm">0.1</span>
                            </div>
                            <button id="generate-data" class="bg-[#3498db] hover:bg-[#4A4ACB] text-white font-medium py-2 px-4 rounded transition">Generate New Data</button>
                        </div>
                    </div>
                    
                    <!-- SVM Parameters -->
                    <div>
                        <h3 class="text-lg font-medium mb-2">SVM Parameters</h3>
                        <div class="flex flex-col gap-2">
                            <div class="flex items-center justify-between">
                                <label for="kernel-type" class="mr-2">Kernel:</label>
                                <select id="kernel-type" class="w-40 px-2 py-1 border rounded dark:bg-gray-700 dark:border-gray-600 dark:text-white text-base">
                                    <option value="linear">Linear</option>
                                    <option value="poly">Polynomial</option>
                                    <option value="rbf" selected>RBF</option>
                                </select>
                            </div>
                            <div>
                                <label for="c-param" class="block mb-1">Regularization (C):</label>
                                <input type="range" id="c-param" min="0.1" max="10" step="0.1" value="1" class="w-full">
                                <div class="flex justify-between text-sm">
                                    <span>0.1</span>
                                    <span id="c-value">1.0</span>
                                    <span>10.0</span>
                                </div>
                            </div>
                            <div id="gamma-container">
                                <label for="gamma-param" class="block mb-1">Gamma:</label>
                                <input type="range" id="gamma-param" min="0.01" max="1" step="0.01" value="0.1" class="w-full">
                                <div class="flex justify-between text-sm">
                                    <span>0.01</span>
                                    <span id="gamma-value">0.1</span>
                                    <span>1.0</span>
                                </div>
                            </div>
                            <div id="degree-container" class="hidden">
                                <label for="degree-param" class="block mb-1">Polynomial Degree:</label>
                                <input type="range" id="degree-param" min="2" max="5" step="1" value="3" class="w-full">
                                <div class="flex justify-between text-sm">
                                    <span>2</span>
                                    <span id="degree-value">3</span>
                                    <span>5</span>
                                </div>
                            </div>
                            <button id="train-svm" class="bg-[#3498db] hover:bg-[#4A4ACB] text-white font-medium py-2 px-4 rounded transition">Train SVM</button>
                        </div>
                    </div>
                    
                    <!-- Algorithm Parameters -->
                    <div>
                        <h3 class="text-lg font-medium mb-2">Algorithm Parameters</h3>
                        <div class="flex flex-col gap-2">
                            <div>
                                <label for="max-iterations" class="block mb-1">Max Iterations:</label>
                                <input type="number" id="max-iterations" min="10" max="1000" value="100" class="w-full px-2 py-1 border rounded dark:bg-gray-700 dark:border-gray-600 dark:text-white text-base">
                            </div>
                            <div class="flex items-center justify-between">
                                <label for="convergence-threshold" class="mr-2">Convergence Threshold:</label>
                                <input type="number" id="convergence-threshold" min="0.0001" max="0.1" step="0.0001" value="0.001" class="w-32 px-2 py-1 border rounded dark:bg-gray-700 dark:border-gray-600 dark:text-white text-base">
                            </div>
                        </div>
                    </div>
                    
                    <!-- Playback Controls -->
                    <div>
                        <h3 class="text-lg font-medium mb-2">Playback</h3>
                        <div class="flex flex-col gap-2">
                            <div class="flex space-x-2">
                                <button id="reset" class="bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 font-medium py-2 px-4 rounded transition flex-1">Reset</button>
                                <button id="step" class="bg-[#3498db] hover:bg-[#4A4ACB] text-white font-medium py-2 px-4 rounded transition flex-1">Step</button>
                                <button id="play" class="bg-green-600 hover:bg-green-700 text-white font-medium py-2 px-4 rounded transition flex-1">Play</button>
                            </div>
                            <div>
                                <label for="animation-speed" class="block mb-1">Animation Speed:</label>
                                <input type="range" id="animation-speed" min="0.5" max="5" step="0.1" value="1" class="w-full">
                                <div class="flex justify-between text-sm">
                                    <span>Slow</span>
                                    <span id="animation-speed-value">1x</span>
                                    <span>Fast</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Status and Info -->
                    <div>
                        <h3 class="text-lg font-medium mb-2">Status</h3>
                        <div class="p-2 bg-gray-100 dark:bg-gray-700 rounded">
                            <div class="flex justify-between mb-1">
                                <span>Iteration:</span>
                                <span id="current-iteration">0 / 100</span>
                            </div>
                            <div class="flex justify-between mb-1">
                                <span>Objective Value:</span>
                                <span id="current-objective">-</span>
                            </div>
                            <div class="flex justify-between mb-1">
                                <span>Support Vectors:</span>
                                <span id="num-support-vectors">0</span>
                            </div>
                            <div class="flex justify-between">
                                <span>Accuracy:</span>
                                <span id="current-accuracy">-</span>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Visualization Options -->
                    <div>
                        <h3 class="text-lg font-medium mb-2">Visualization Options</h3>
                        <div class="flex flex-col gap-2">
                            <div class="flex items-center gap-2">
                                <input type="checkbox" id="show-margin" class="w-4 h-4" checked>
                                <label for="show-margin">Show Margins</label>
                            </div>
                            <div class="flex items-center gap-2">
                                <input type="checkbox" id="show-support-vectors" class="w-4 h-4" checked>
                                <label for="show-support-vectors">Highlight Support Vectors</label>
                            </div>
                            <div class="flex items-center gap-2">
                                <input type="checkbox" id="show-decision-region" class="w-4 h-4" checked>
                                <label for="show-decision-region">Show Decision Region</label>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Objective Function Visualization -->
        <div class="mt-6 bg-white dark:bg-gray-800 rounded-lg shadow-lg p-4">
            <h2 class="text-xl font-semibold mb-4 text-[#3498db] dark:text-[#3498db]">Objective Value Over Iterations</h2>
            <div class="w-full h-[200px]">
                <svg id="objective-visualization" class="w-full h-full" viewBox="0 0 1000 200"></svg>
            </div>
        </div>
        
        <!-- Explanation Section -->
        <div class="mt-6 bg-white dark:bg-gray-800 rounded-lg shadow-lg p-4">
            <h2 class="text-xl font-semibold mb-4 text-[#3498db] dark:text-[#3498db]">How Support Vector Machines Work</h2>
            <div class="space-y-3 text-sm md:text-base">
                <p><strong>Step 1: Mapping</strong> - For non-linear problems, SVM maps the data into a higher-dimensional space using kernel functions where it becomes linearly separable.</p>
                <p><strong>Step 2: Maximum Margin</strong> - SVM finds the optimal hyperplane that maximizes the margin between classes. The margin is the distance between the hyperplane and the nearest data points (support vectors).</p>
                <p><strong>Step 3: Support Vectors</strong> - These are the data points closest to the decision boundary and most difficult to classify. They define the position of the hyperplane.</p>
                <p><strong>Step 4: Regularization (C parameter)</strong> - Controls the trade-off between maximizing the margin and minimizing classification error. Lower C allows more misclassifications but with a wider margin.</p>
                <p><strong>Step 5: Kernel Functions</strong> - Enable SVMs to handle non-linear data by implicitly mapping to higher dimensions:</p>
                <ul class="list-disc ml-6">
                    <li><strong>Linear:</strong> Simple dot product for linearly separable data</li>
                    <li><strong>Polynomial:</strong> For curved boundaries, controlled by degree parameter</li>
                    <li><strong>RBF (Gaussian):</strong> For complex boundaries, controlled by gamma parameter</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        // Initialize dark mode based on user preference
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.body.classList.add('dark');
        }
        
        // DOM elements
        const svg = document.getElementById('visualization');
        const objectiveSvg = document.getElementById('objective-visualization');
        const generateDataBtn = document.getElementById('generate-data');
        const trainSvmBtn = document.getElementById('train-svm');
        const kernelTypeSelect = document.getElementById('kernel-type');
        const cParamInput = document.getElementById('c-param');
        const cValueDisplay = document.getElementById('c-value');
        const gammaParamInput = document.getElementById('gamma-param');
        const gammaValueDisplay = document.getElementById('gamma-value');
        const degreeParamInput = document.getElementById('degree-param');
        const degreeValueDisplay = document.getElementById('degree-value');
        const gammaContainer = document.getElementById('gamma-container');
        const degreeContainer = document.getElementById('degree-container');
        const maxIterationsInput = document.getElementById('max-iterations');
        const convergenceThresholdInput = document.getElementById('convergence-threshold');
        const numPointsInput = document.getElementById('num-points');
        const dataComplexitySelect = document.getElementById('data-complexity');
        const noiseLevelInput = document.getElementById('noise-level');
        const noiseValueDisplay = document.getElementById('noise-value');
        const resetBtn = document.getElementById('reset');
        const stepBtn = document.getElementById('step');
        const playBtn = document.getElementById('play');
        const animationSpeedInput = document.getElementById('animation-speed');
        const animationSpeedValue = document.getElementById('animation-speed-value');
        const currentIterationEl = document.getElementById('current-iteration');
        const currentObjectiveEl = document.getElementById('current-objective');
        const numSupportVectorsEl = document.getElementById('num-support-vectors');
        const currentAccuracyEl = document.getElementById('current-accuracy');
        const showMarginCheckbox = document.getElementById('show-margin');
        const showSupportVectorsCheckbox = document.getElementById('show-support-vectors');
        const showDecisionRegionCheckbox = document.getElementById('show-decision-region');
        
        // SVG namespace
        const svgNS = "http://www.w3.org/2000/svg";
        
        // Visualization constants
        const WIDTH = 1000;
        const HEIGHT = 600;
        const MARGIN = 50;
        const PLOT_WIDTH = WIDTH - 2 * MARGIN;
        const PLOT_HEIGHT = HEIGHT - 2 * MARGIN;
        
        // Data visualization constants
        const DATA_HEIGHT = HEIGHT * 0.55 - MARGIN * 1.5;
        const DATA_WIDTH = WIDTH - MARGIN * 2;
        const DATA_X = MARGIN;
        const DATA_Y = MARGIN;
        
        // SVM visualization constants
        const SVM_HEIGHT = HEIGHT * 0.45 - MARGIN * 1.5;
        const SVM_WIDTH = WIDTH - MARGIN * 2;
        const SVM_X = MARGIN;
        const SVM_Y = DATA_Y + DATA_HEIGHT + MARGIN;
        
        // Objective function visualization constants
        const OBJECTIVE_HEIGHT = 200;
        const OBJECTIVE_MARGIN = 30;
        const OBJECTIVE_PLOT_HEIGHT = OBJECTIVE_HEIGHT - 2 * OBJECTIVE_MARGIN;
        
        // Colors
        const CLASS_0_COLOR = '#EF4444'; // Red
        const CLASS_1_COLOR = '#3B82F6'; // Blue
        const BOUNDARY_COLOR = '#3498db'; // Purple
        const MARGIN_COLOR = '#3498db'; // Lighter purple
        const SUPPORT_VECTOR_COLOR = '#FCD34D'; // Yellow
        
        // Data and model parameters
        let data = [];
        let kernel = 'rbf';
        let C = 1.0;
        let gamma = 0.1;
        let degree = 3;
        let maxIterations = 100;
        let convergenceThreshold = 0.001;
        let noiseLevel = 0.1;
        
        // SVM model variables
        let alpha = []; // Lagrange multipliers
        let bias = 0; // Bias term
        let objectiveValues = [];
        let iterations = [];
        let supportVectorIndices = [];
        let currentIteration = 0;
        let animationSpeed = 1;
        let animationInterval = null;
        
        // Initialize the SVG elements
        function initSVG() {
            // Clear existing SVGs
            svg.innerHTML = '';
            objectiveSvg.innerHTML = '';
            
            // Add background for main visualization
            const background = document.createElementNS(svgNS, 'rect');
            background.setAttribute('width', WIDTH);
            background.setAttribute('height', HEIGHT);
            background.setAttribute('fill', document.body.classList.contains('dark') ? '#1F2937' : '#f8fafc');
            svg.appendChild(background);
            
            // Add separator between SVM and data visualizations
            const separator = document.createElementNS(svgNS, 'line');
            separator.setAttribute('x1', MARGIN);
            separator.setAttribute('y1', SVM_Y - MARGIN/2);
            separator.setAttribute('x2', WIDTH - MARGIN+5);
            separator.setAttribute('y2', SVM_Y - MARGIN/2);
            separator.setAttribute('stroke', document.body.classList.contains('dark') ? '#374151' : '#e2e8f0');
            separator.setAttribute('stroke-width', '2');
            separator.setAttribute('stroke-dasharray', '5,5');
            svg.appendChild(separator);
            
            // Add grid lines for data visualization
            for (let i = 0; i <= 10; i++) {
                const xPos = DATA_X + (DATA_WIDTH / 10) * i;
                const yPos = DATA_Y + (DATA_HEIGHT / 10) * i;
                
                // Vertical grid line
                const vLine = document.createElementNS(svgNS, 'line');
                vLine.setAttribute('x1', xPos);
                vLine.setAttribute('y1', DATA_Y);
                vLine.setAttribute('x2', xPos);
                vLine.setAttribute('y2', DATA_Y + DATA_HEIGHT);
                vLine.setAttribute('stroke', document.body.classList.contains('dark') ? '#374151' : '#e2e8f0');
                vLine.setAttribute('stroke-width', '1');
                svg.appendChild(vLine);
                
                // Horizontal grid line
                const hLine = document.createElementNS(svgNS, 'line');
                hLine.setAttribute('x1', DATA_X);
                hLine.setAttribute('y1', yPos);
                hLine.setAttribute('x2', DATA_X + DATA_WIDTH);
                hLine.setAttribute('y2', yPos);
                hLine.setAttribute('stroke', document.body.classList.contains('dark') ? '#374151' : '#e2e8f0');
                hLine.setAttribute('stroke-width', '1');
                svg.appendChild(hLine);
            }
            
            // Add axes for data visualization
            const xAxis = document.createElementNS(svgNS, 'line');
            xAxis.setAttribute('x1', DATA_X);
            xAxis.setAttribute('y1', DATA_Y + DATA_HEIGHT);
            xAxis.setAttribute('x2', DATA_X + DATA_WIDTH);
            xAxis.setAttribute('y2', DATA_Y + DATA_HEIGHT);
            xAxis.setAttribute('stroke', document.body.classList.contains('dark') ? '#d1d5db' : '#1f2937');
            xAxis.setAttribute('stroke-width', '2');
            svg.appendChild(xAxis);
            
            const yAxis = document.createElementNS(svgNS, 'line');
            yAxis.setAttribute('x1', DATA_X);
            yAxis.setAttribute('y1', DATA_Y);
            yAxis.setAttribute('x2', DATA_X);
            yAxis.setAttribute('y2', DATA_Y + DATA_HEIGHT);
            yAxis.setAttribute('stroke', document.body.classList.contains('dark') ? '#d1d5db' : '#1f2937');
            yAxis.setAttribute('stroke-width', '2');
            svg.appendChild(yAxis);
            
            // Add axis labels for data visualization
            const xLabel = document.createElementNS(svgNS, 'text');
            xLabel.setAttribute('x', DATA_X + DATA_WIDTH / 2);
            xLabel.setAttribute('y', DATA_Y + DATA_HEIGHT + 30);
            xLabel.setAttribute('text-anchor', 'middle');
            xLabel.setAttribute('fill', document.body.classList.contains('dark') ? '#d1d5db' : '#1f2937');
            xLabel.textContent = 'Feature X‚ÇÅ';
            svg.appendChild(xLabel);
            
            const yLabel = document.createElementNS(svgNS, 'text');
            yLabel.setAttribute('x', DATA_X - 30);
            yLabel.setAttribute('y', DATA_Y + DATA_HEIGHT / 2);
            yLabel.setAttribute('text-anchor', 'middle');
            yLabel.setAttribute('transform', `rotate(-90, ${DATA_X - 30}, ${DATA_Y + DATA_HEIGHT / 2})`);
            yLabel.setAttribute('fill', document.body.classList.contains('dark') ? '#d1d5db' : '#1f2937');
            yLabel.textContent = 'Feature X‚ÇÇ';
            svg.appendChild(yLabel);
            
            // Add titles for data and SVM sections
            const dataTitle = document.createElementNS(svgNS, 'text');
            dataTitle.setAttribute('x', DATA_X + DATA_WIDTH / 2);
            dataTitle.setAttribute('y', DATA_Y - 20);
            dataTitle.setAttribute('text-anchor', 'middle');
            dataTitle.setAttribute('fill', document.body.classList.contains('dark') ? '#d1d5db' : '#1f2937');
            dataTitle.setAttribute('font-weight', 'bold');
            dataTitle.textContent = 'Data & Decision Boundary';
            svg.appendChild(dataTitle);
            
            
            // Add background for objective function visualization
            const objectiveBackground = document.createElementNS(svgNS, 'rect');
            objectiveBackground.setAttribute('width', WIDTH);
            objectiveBackground.setAttribute('height', OBJECTIVE_HEIGHT);
            objectiveBackground.setAttribute('fill', document.body.classList.contains('dark') ? '#1F2937' : '#f8fafc');
            objectiveSvg.appendChild(objectiveBackground);
            
            // Add axes for objective function visualization
            const objectiveXAxis = document.createElementNS(svgNS, 'line');
            objectiveXAxis.setAttribute('x1', OBJECTIVE_MARGIN);
            objectiveXAxis.setAttribute('y1', OBJECTIVE_HEIGHT - OBJECTIVE_MARGIN);
            objectiveXAxis.setAttribute('x2', WIDTH - OBJECTIVE_MARGIN);
            objectiveXAxis.setAttribute('y2', OBJECTIVE_HEIGHT - OBJECTIVE_MARGIN);
            objectiveXAxis.setAttribute('stroke', document.body.classList.contains('dark') ? '#d1d5db' : '#1f2937');
            objectiveXAxis.setAttribute('stroke-width', '2');
            objectiveSvg.appendChild(objectiveXAxis);
            
            const objectiveYAxis = document.createElementNS(svgNS, 'line');
            objectiveYAxis.setAttribute('x1', OBJECTIVE_MARGIN);
            objectiveYAxis.setAttribute('y1', OBJECTIVE_MARGIN);
            objectiveYAxis.setAttribute('x2', OBJECTIVE_MARGIN);
            objectiveYAxis.setAttribute('y2', OBJECTIVE_HEIGHT - OBJECTIVE_MARGIN);
            objectiveYAxis.setAttribute('stroke', document.body.classList.contains('dark') ? '#d1d5db' : '#1f2937');
            objectiveYAxis.setAttribute('stroke-width', '2');
            objectiveSvg.appendChild(objectiveYAxis);
            
            // Add axis labels for objective function visualization
            const objectiveXLabel = document.createElementNS(svgNS, 'text');
            objectiveXLabel.setAttribute('x', WIDTH / 2);
            objectiveXLabel.setAttribute('y', OBJECTIVE_HEIGHT - 5);
            objectiveXLabel.setAttribute('text-anchor', 'middle');
            objectiveXLabel.setAttribute('fill', document.body.classList.contains('dark') ? '#d1d5db' : '#1f2937');
            objectiveXLabel.textContent = 'Iterations';
            objectiveSvg.appendChild(objectiveXLabel);
            
            const objectiveYLabel = document.createElementNS(svgNS, 'text');
            objectiveYLabel.setAttribute('x', 15);
            objectiveYLabel.setAttribute('y', OBJECTIVE_HEIGHT / 2);
            objectiveYLabel.setAttribute('text-anchor', 'middle');
            objectiveYLabel.setAttribute('transform', `rotate(-90, 15, ${OBJECTIVE_HEIGHT / 2})`);
            objectiveYLabel.setAttribute('fill', document.body.classList.contains('dark') ? '#d1d5db' : '#1f2937');
            objectiveYLabel.textContent = 'Objective Value';
            objectiveSvg.appendChild(objectiveYLabel);
        }
        
        // Generate synthetic data for binary classification
        function generateData() {
            const numPoints = parseInt(numPointsInput.value);
            const complexity = dataComplexitySelect.value;
            noiseLevel = parseFloat(noiseLevelInput.value);
            data = [];
            
            for (let i = 0; i < numPoints; i++) {
                let x1, x2, y;
                
                // Generate different data patterns based on complexity
                switch (complexity) {
                    case 'linearly-separable':
                        // Linear separation
                        x1 = Math.random() * 10;
                        x2 = Math.random() * 10;
                        // Add a diagonal line with some margin
                        y = (x1 > x2 + 1) ? 1 : -1;
                        break;
                        
                    case 'circle':
                        // Circular pattern (points inside a circle are one class)
                        x1 = Math.random() * 10;
                        x2 = Math.random() * 10;
                        const centerX = 5;
                        const centerY = 5;
                        const radius = 3;
                        const distance = Math.sqrt(Math.pow(x1 - centerX, 2) + Math.pow(x2 - centerY, 2));
                        y = distance < radius ? 1 : -1;
                        break;
                        
                    case 'moons':
                        // Two moons pattern
                        let angle, r;
                        if (Math.random() < 0.5) {
                            // First moon
                            angle = Math.random() * Math.PI;
                            r = 3;
                            x1 = 5 + r * Math.cos(angle);
                            x2 = 5 + r * Math.sin(angle);
                            y = 1;
                        } else {
                            // Second moon
                            angle = Math.random() * Math.PI;
                            r = 3;
                            x1 = 5 - r * Math.cos(angle);
                            x2 = 5 - r * Math.sin(angle) + 3;
                            y = -1;
                        }
                        
                        // Ensure x1 and x2 are within range
                        x1 = Math.max(0, Math.min(10, x1));
                        x2 = Math.max(0, Math.min(10, x2));
                        break;
                        
                    case 'xor':
                        // XOR pattern
                        x1 = Math.random() * 10;
                        x2 = Math.random() * 10;
                        y = ((x1 < 5 && x2 < 5) || (x1 >= 5 && x2 >= 5)) ? 1 : -1;
                        break;
                        
                    default:
                        // Default to circle if unknown
                        x1 = Math.random() * 10;
                        x2 = Math.random() * 10;
                        const defCenterX = 5;
                        const defCenterY = 5;
                        const defRadius = 3;
                        const defDistance = Math.sqrt(Math.pow(x1 - defCenterX, 2) + Math.pow(x2 - defCenterY, 2));
                        y = defDistance < defRadius ? 1 : -1;
                }
                
                // Add noise
                if (Math.random() < noiseLevel) {
                    y = -y; // Flip the label
                }
                
                data.push({ x1, x2, y });
            }
            
            // Reset model and visualizations
            resetModel();
            visualizeData();
            updateObjectivePlot();
            visualizeSVMModelSpace();
        }
        
        // Reset the SVM model
        function resetModel() {
            // Get parameters from UI
            kernel = kernelTypeSelect.value;
            C = parseFloat(cParamInput.value);
            gamma = parseFloat(gammaParamInput.value);
            degree = parseInt(degreeParamInput.value);
            maxIterations = parseInt(maxIterationsInput.value);
            convergenceThreshold = parseFloat(convergenceThresholdInput.value);
            
            // Initialize alpha values to 0
            alpha = Array(data.length).fill(0);
            bias = 0;
            
            // Reset training metrics
            objectiveValues = [];
            iterations = [];
            supportVectorIndices = [];
            currentIteration = 0;
            
            stopAnimation();
            
            // Update UI
            currentIterationEl.textContent = `0 / ${maxIterations}`;
            currentObjectiveEl.textContent = '-';
            numSupportVectorsEl.textContent = '0';
            currentAccuracyEl.textContent = '-';
            
            // Visualize initial decision boundary (just for showing something)
            visualizeDecisionBoundary();
            visualizeSVMModelSpace();
        }
        
        // Map data coordinates to SVG coordinates in the data visualization area
        function mapDataX(x) {
            return DATA_X + (x / 10) * DATA_WIDTH;
        }
        
        function mapDataY(y) {
            return DATA_Y + DATA_HEIGHT - (y / 10) * DATA_HEIGHT;
        }
        
        // Visualize the data points
        function visualizeData() {
            // Remove existing data points
            const existingPoints = svg.querySelectorAll('.data-point');
            existingPoints.forEach(point => point.remove());
            
            // Add new data points
            data.forEach((point, index) => {
                const circle = document.createElementNS(svgNS, 'circle');
                circle.setAttribute('cx', mapDataX(point.x1));
                circle.setAttribute('cy', mapDataY(point.x2));
                circle.setAttribute('r', '6');
                circle.setAttribute('fill', point.y === 1 ? CLASS_1_COLOR : CLASS_0_COLOR);
                circle.setAttribute('stroke', document.body.classList.contains('dark') ? '#F3F4F6' : '#1F2937');
                circle.setAttribute('stroke-width', '1');
                circle.setAttribute('class', 'data-point');
                circle.setAttribute('data-index', index);
                
                // Add animation with anime.js
                circle.style.opacity = '0';
                circle.style.transform = 'scale(0)';
                
                svg.appendChild(circle);
            });
            
            // Animate the appearance of data points
            anime({
                targets: '.data-point',
                opacity: 1,
                scale: 1,
                delay: anime.stagger(20),
                easing: 'easeOutElastic(1, .5)',
                duration: 1500
            });
        }
        
        // Compute kernel value between two data points
        function computeKernel(x1, x2) {
            switch (kernel) {
                case 'linear':
                    return x1.x1 * x2.x1 + x1.x2 * x2.x2;
                    
                case 'poly':
                    return Math.pow((x1.x1 * x2.x1 + x1.x2 * x2.x2 + 1), degree);
                    
                case 'rbf':
                    const sqDist = Math.pow(x1.x1 - x2.x1, 2) + Math.pow(x1.x2 - x2.x2, 2);
                    return Math.exp(-gamma * sqDist);
                    
                default:
                    return x1.x1 * x2.x1 + x1.x2 * x2.x2; // Default to linear
            }
        }
        
        // Compute the decision function value for a data point
        function computeDecisionFunction(point) {
            let decision = bias;
            
            for (let i = 0; i < data.length; i++) {
                if (Math.abs(alpha[i]) > 1e-5) {
                    decision += alpha[i] * data[i].y * computeKernel(data[i], point);
                }
            }
            
            return decision;
        }
        
        // Predict the class of a data point
        function predict(point) {
            return computeDecisionFunction(point) >= 0 ? 1 : -1;
        }
        
        // Calculate the accuracy of the model
        function calculateAccuracy() {
            let correct = 0;
            
            for (const point of data) {
                const prediction = predict(point);
                
                if (prediction === point.y) {
                    correct++;
                }
            }
            
            return correct / data.length;
        }
        
        // Visualize the decision boundary
        function visualizeDecisionBoundary() {
            // Only show decision region if requested
            if (showDecisionRegionCheckbox.checked) {
                visualizeDecisionRegion();
            } else {
                // Remove existing decision region
                const existingRegion = svg.querySelector('.decision-region-group');
                if (existingRegion) {
                    existingRegion.remove();
                }
            }
            
            // Visualize decision boundary lines and margins
            visualizeBoundaryLines();
            
            // Highlight support vectors if requested
            if (showSupportVectorsCheckbox.checked) {
                highlightSupportVectors();
            } else {
                // Reset all data points to original appearance
                const dataPoints = svg.querySelectorAll('.data-point');
                dataPoints.forEach(point => {
                    point.setAttribute('stroke', document.body.classList.contains('dark') ? '#F3F4F6' : '#1F2937');
                    point.setAttribute('stroke-width', '1');
                });
            }
        }
        
        // Visualize the decision region using a grid of predictions
        function visualizeDecisionRegion() {
            // Remove existing decision region
            const existingRegion = svg.querySelector('.decision-region-group');
            if (existingRegion) {
                existingRegion.remove();
            }
            
            // Create a group for the decision region
            const regionGroup = document.createElementNS(svgNS, 'g');
            regionGroup.setAttribute('class', 'decision-region-group');
            
            // Create a grid of predictions
            const gridSize = 40; // 40x40 grid
            const cellSize = 10 / gridSize;
            
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    const x1 = i * cellSize;
                    const x2 = j * cellSize;
                    
                    // Create a test point
                    const testPoint = { x1, x2 };
                    
                    // Compute decision function value
                    const decisionValue = computeDecisionFunction(testPoint);
                    
                    // Create grid cell
                    const cell = document.createElementNS(svgNS, 'rect');
                    cell.setAttribute('x', mapDataX(x1));
                    cell.setAttribute('y', mapDataY(x2 + cellSize));
                    cell.setAttribute('width', DATA_WIDTH / gridSize);
                    cell.setAttribute('height', DATA_HEIGHT / gridSize);
                    
                    // Set color based on prediction
                    const intensity = 1 / (1 + Math.exp(-5 * decisionValue)); // Sigmoid to get [0,1]
                    const color = decisionValue >= 0 ? CLASS_1_COLOR : CLASS_0_COLOR;
                    
                    cell.setAttribute('fill', color);
                    cell.setAttribute('opacity', intensity * 0.3);
                    cell.setAttribute('class', 'decision-region-cell');
                    
                    regionGroup.appendChild(cell);
                }
            }
            
            // Add decision region to the SVG before data points
            svg.insertBefore(regionGroup, svg.querySelector('.data-point'));
            
            // Animate the region appearance
            anime({
                targets: '.decision-region-cell',
                opacity: [0, el => parseFloat(el.getAttribute('opacity'))],
                delay: anime.stagger(1, {
                    grid: [gridSize, gridSize],
                    from: 'center'
                }),
                easing: 'easeInOutSine',
                duration: 500
            });
        }
        
        // Visualize the decision boundary and margin lines
        function visualizeBoundaryLines() {
            // Remove existing boundary lines
            const existingLines = svg.querySelectorAll('.boundary-line, .margin-line');
            existingLines.forEach(line => line.remove());
            
            // For linear kernel, we can directly visualize the decision boundary as a line
            if (kernel === 'linear' && supportVectorIndices.length > 0) {
                // Compute w vector
                let w1 = 0, w2 = 0;
                for (let i = 0; i < data.length; i++) {
                    if (Math.abs(alpha[i]) > 1e-5) {
                        w1 += alpha[i] * data[i].y * data[i].x1;
                        w2 += alpha[i] * data[i].y * data[i].x2;
                    }
                }
                
                if (w2 !== 0) {
                    // Decision boundary: w1*x1 + w2*x2 + b = 0
                    // -> x2 = (-w1*x1 - b) / w2
                    const x1_1 = 0;
                    const x1_2 = 10;
                    const x2_1 = (-w1 * x1_1 - bias) / w2;
                    const x2_2 = (-w1 * x1_2 - bias) / w2;
                    
                    // Create decision boundary line
                    const boundaryLine = document.createElementNS(svgNS, 'line');
                    boundaryLine.setAttribute('x1', mapDataX(x1_1));
                    boundaryLine.setAttribute('y1', mapDataY(x2_1));
                    boundaryLine.setAttribute('x2', mapDataX(x1_2));
                    boundaryLine.setAttribute('y2', mapDataY(x2_2));
                    boundaryLine.setAttribute('stroke', BOUNDARY_COLOR);
                    boundaryLine.setAttribute('stroke-width', '3');
                    boundaryLine.setAttribute('class', 'boundary-line');
                    
                    svg.appendChild(boundaryLine);
                    
                    // Animate the boundary line
                    anime({
                        targets: '.boundary-line',
                        strokeDashoffset: [anime.setDashoffset, 0],
                        easing: 'easeInOutSine',
                        duration: 1000
                    });
                    
                    // If showing margins, draw the margin lines
                    if (showMarginCheckbox.checked) {
                        // Margin lines: w1*x1 + w2*x2 + b = ¬±1
                        // -> x2 = (-w1*x1 - b ¬± 1) / w2
                        const margin_pos_x2_1 = (-w1 * x1_1 - bias + 1) / w2;
                        const margin_pos_x2_2 = (-w1 * x1_2 - bias + 1) / w2;
                        const margin_neg_x2_1 = (-w1 * x1_1 - bias - 1) / w2;
                        const margin_neg_x2_2 = (-w1 * x1_2 - bias - 1) / w2;
                        
                        // Create positive margin line
                        const marginPosLine = document.createElementNS(svgNS, 'line');
                        marginPosLine.setAttribute('x1', mapDataX(x1_1));
                        marginPosLine.setAttribute('y1', mapDataY(margin_pos_x2_1));
                        marginPosLine.setAttribute('x2', mapDataX(x1_2));
                        marginPosLine.setAttribute('y2', mapDataY(margin_pos_x2_2));
                        marginPosLine.setAttribute('stroke', MARGIN_COLOR);
                        marginPosLine.setAttribute('stroke-width', '2');
                        marginPosLine.setAttribute('stroke-dasharray', '5,5');
                        marginPosLine.setAttribute('class', 'margin-line');
                        
                        svg.appendChild(marginPosLine);
                        
                        // Create negative margin line
                        const marginNegLine = document.createElementNS(svgNS, 'line');
                        marginNegLine.setAttribute('x1', mapDataX(x1_1));
                        marginNegLine.setAttribute('y1', mapDataY(margin_neg_x2_1));
                        marginNegLine.setAttribute('x2', mapDataX(x1_2));
                        marginNegLine.setAttribute('y2', mapDataY(margin_neg_x2_2));
                        marginNegLine.setAttribute('stroke', MARGIN_COLOR);
                        marginNegLine.setAttribute('stroke-width', '2');
                        marginNegLine.setAttribute('stroke-dasharray', '5,5');
                        marginNegLine.setAttribute('class', 'margin-line');
                        
                        svg.appendChild(marginNegLine);
                        
                        // Animate the margin lines
                        anime({
                            targets: '.margin-line',
                            strokeDashoffset: [anime.setDashoffset, 0],
                            easing: 'easeInOutSine',
                            duration: 1000,
                            delay: 500
                        });
                    }
                }
            } else {
                // For non-linear kernels, visualize the decision boundary as a contour line
                // This is computationally expensive, so we'll use a simplified approach
                
                // Create a set of points along the decision boundary
                const boundaryPoints = [];
                const gridSize = 100;
                const cellSize = 10 / gridSize;
                
                for (let i = 0; i < gridSize; i++) {
                    for (let j = 0; j < gridSize; j++) {
                        const x1 = i * cellSize;
                        const x2 = j * cellSize;
                        const testPoint = { x1, x2 };
                        const decisionValue = computeDecisionFunction(testPoint);
                        
                        // Check if near the decision boundary
                        if (Math.abs(decisionValue) < 0.1) {
                            boundaryPoints.push({ x1, x2 });
                        }
                    }
                }
                
                // Sort boundary points to create a smoother line
                if (boundaryPoints.length > 0) {
                    // Draw the boundary points as small circles
                    const boundaryGroup = document.createElementNS(svgNS, 'g');
                    boundaryGroup.setAttribute('class', 'boundary-line');
                    
                    boundaryPoints.forEach(point => {
                        const circle = document.createElementNS(svgNS, 'circle');
                        circle.setAttribute('cx', mapDataX(point.x1));
                        circle.setAttribute('cy', mapDataY(point.x2));
                        circle.setAttribute('r', '2');
                        circle.setAttribute('fill', BOUNDARY_COLOR);
                        boundaryGroup.appendChild(circle);
                    });
                    
                    svg.appendChild(boundaryGroup);
                    
                    // Animate the boundary points
                    anime({
                        targets: '.boundary-line circle',
                        opacity: [0, 1],
                        scale: [0, 1],
                        delay: anime.stagger(5),
                        easing: 'easeInOutSine',
                        duration: 500
                    });
                }
                
                // If showing margins, visualize the margin boundaries
                if (showMarginCheckbox.checked) {
                    // For positive margin
                    const posMarginPoints = [];
                    // For negative margin
                    const negMarginPoints = [];
                    
                    for (let i = 0; i < gridSize; i++) {
                        for (let j = 0; j < gridSize; j++) {
                            const x1 = i * cellSize;
                            const x2 = j * cellSize;
                            const testPoint = { x1, x2 };
                            const decisionValue = computeDecisionFunction(testPoint);
                            
                            // Check if near the margins
                            if (Math.abs(decisionValue - 1) < 0.1) {
                                posMarginPoints.push({ x1, x2 });
                            } else if (Math.abs(decisionValue + 1) < 0.1) {
                                negMarginPoints.push({ x1, x2 });
                            }
                        }
                    }
                    
                    // Draw positive margin points
                    if (posMarginPoints.length > 0) {
                        const posMarginGroup = document.createElementNS(svgNS, 'g');
                        posMarginGroup.setAttribute('class', 'margin-line pos-margin');
                        
                        posMarginPoints.forEach(point => {
                            const circle = document.createElementNS(svgNS, 'circle');
                            circle.setAttribute('cx', mapDataX(point.x1));
                            circle.setAttribute('cy', mapDataY(point.x2));
                            circle.setAttribute('r', '1.5');
                            circle.setAttribute('fill', MARGIN_COLOR);
                            posMarginGroup.appendChild(circle);
                        });
                        
                        svg.appendChild(posMarginGroup);
                    }
                    
                    // Draw negative margin points
                    if (negMarginPoints.length > 0) {
                        const negMarginGroup = document.createElementNS(svgNS, 'g');
                        negMarginGroup.setAttribute('class', 'margin-line neg-margin');
                        
                        negMarginPoints.forEach(point => {
                            const circle = document.createElementNS(svgNS, 'circle');
                            circle.setAttribute('cx', mapDataX(point.x1));
                            circle.setAttribute('cy', mapDataY(point.x2));
                            circle.setAttribute('r', '1.5');
                            circle.setAttribute('fill', MARGIN_COLOR);
                            negMarginGroup.appendChild(circle);
                        });
                        
                        svg.appendChild(negMarginGroup);
                    }
                    
                    // Animate the margin points
                    anime({
                        targets: '.margin-line circle',
                        opacity: [0, 1],
                        scale: [0, 1],
                        delay: anime.stagger(2),
                        easing: 'easeInOutSine',
                        duration: 300
                    });
                }
            }
        }
        
        // Highlight support vectors
        function highlightSupportVectors() {
            // Reset all data points to original appearance
            const dataPoints = svg.querySelectorAll('.data-point');
            dataPoints.forEach(point => {
                point.setAttribute('stroke', document.body.classList.contains('dark') ? '#F3F4F6' : '#1F2937');
                point.setAttribute('stroke-width', '1');
            });
            
            // Highlight support vectors
            supportVectorIndices.forEach(index => {
                const svPoint = svg.querySelector(`.data-point[data-index="${index}"]`);
                if (svPoint) {
                    svPoint.setAttribute('stroke', SUPPORT_VECTOR_COLOR);
                    svPoint.setAttribute('stroke-width', '3');
                    
                    // Add pulse animation
                    anime({
                        targets: svPoint,
                        r: [6, 9, 6],
                        duration: 1000,
                        easing: 'easeInOutSine',
                        loop: 1
                    });
                }
            });
        }
        
        // Visualize the SVM model space
        function visualizeSVMModelSpace() {
            // Remove existing SVM visualization elements
            const existingSVMElements = svg.querySelectorAll('.svm-element');
            existingSVMElements.forEach(el => el.remove());
            
            // Create SVM visualization group
            const svmGroup = document.createElementNS(svgNS, 'g');
            svmGroup.setAttribute('class', 'svm-group');
            
            // Visualize different parts of the SVM model based on the kernel type
            if (kernel === 'linear') {
                visualizeLinearSVMSpace(svmGroup);
            } else if (kernel === 'poly') {
                visualizePolynomialSVMSpace(svmGroup);
            } else if (kernel === 'rbf') {
                visualizeRBFSVMSpace(svmGroup);
            }
            
            svg.appendChild(svmGroup);
        }
        
        // Visualize linear SVM model space
        function visualizeLinearSVMSpace(svmGroup) {
            // For linear SVM, we can visualize the weight vector and bias
            
            // Create a coordinate system
            const centerX = SVM_X + SVM_WIDTH / 2;
            const centerY = SVM_Y + SVM_HEIGHT / 2;
            const axisLength = Math.min(SVM_WIDTH, SVM_HEIGHT) * 0.7 / 2;
            
            // Title with more space at the top
            const title = document.createElementNS(svgNS, 'text');
            title.setAttribute('x', centerX);
            title.setAttribute('y', SVM_Y + 30);
            title.setAttribute('text-anchor', 'middle');
            title.setAttribute('font-size', '16');
            title.setAttribute('fill', document.body.classList.contains('dark') ? '#d1d5db' : '#1f2937');
            title.setAttribute('class', 'svm-element');
            title.textContent = 'Linear SVM: Weight Vector Space';
            svmGroup.appendChild(title);
            
            // X-axis
            const xAxis = document.createElementNS(svgNS, 'line');
            xAxis.setAttribute('x1', centerX - axisLength);
            xAxis.setAttribute('y1', centerY);
            xAxis.setAttribute('x2', centerX + axisLength);
            xAxis.setAttribute('y2', centerY);
            xAxis.setAttribute('stroke', document.body.classList.contains('dark') ? '#d1d5db' : '#1f2937');
            xAxis.setAttribute('stroke-width', '2');
            xAxis.setAttribute('class', 'svm-element');
            svmGroup.appendChild(xAxis);
            
            // Y-axis
            const yAxis = document.createElementNS(svgNS, 'line');
            yAxis.setAttribute('x1', centerX);
            yAxis.setAttribute('y1', centerY - axisLength);
            yAxis.setAttribute('x2', centerX);
            yAxis.setAttribute('y2', centerY + axisLength);
            yAxis.setAttribute('stroke', document.body.classList.contains('dark') ? '#d1d5db' : '#1f2937');
            yAxis.setAttribute('stroke-width', '2');
            yAxis.setAttribute('class', 'svm-element');
            svmGroup.appendChild(yAxis);
            
            // X-axis label - moved further out
            const xLabel = document.createElementNS(svgNS, 'text');
            xLabel.setAttribute('x', centerX + axisLength + 15);
            xLabel.setAttribute('y', centerY + 5);
            xLabel.setAttribute('text-anchor', 'start');
            xLabel.setAttribute('fill', document.body.classList.contains('dark') ? '#d1d5db' : '#1f2937');
            xLabel.setAttribute('class', 'svm-element');
            xLabel.textContent = 'w‚ÇÅ';
            svmGroup.appendChild(xLabel);
            
            // Y-axis label - moved further out
            const yLabel = document.createElementNS(svgNS, 'text');
            yLabel.setAttribute('x', centerX - 10);
            yLabel.setAttribute('y', centerY - axisLength - 15);
            yLabel.setAttribute('text-anchor', 'end');
            yLabel.setAttribute('fill', document.body.classList.contains('dark') ? '#d1d5db' : '#1f2937');
            yLabel.setAttribute('class', 'svm-element');
            yLabel.textContent = 'w‚ÇÇ';
            svmGroup.appendChild(yLabel);
            
            // Origin label - repositioned for clarity
            const originLabel = document.createElementNS(svgNS, 'text');
            originLabel.setAttribute('x', centerX - 15);
            originLabel.setAttribute('y', centerY + 15);
            originLabel.setAttribute('text-anchor', 'end');
            originLabel.setAttribute('fill', document.body.classList.contains('dark') ? '#d1d5db' : '#1f2937');
            originLabel.setAttribute('class', 'svm-element');
            originLabel.textContent = '0';
            svmGroup.appendChild(originLabel);
            
            // Compute w vector (even if not fully trained)
            let w1 = 0, w2 = 0;
            for (let i = 0; i < data.length; i++) {
                if (Math.abs(alpha[i]) > 1e-5) {
                    w1 += alpha[i] * data[i].y * data[i].x1;
                    w2 += alpha[i] * data[i].y * data[i].x2;
                }
            }
            
            // Normalize for visualization
            const wNorm = Math.sqrt(w1*w1 + w2*w2);
            if (wNorm > 0) {
                const scaleFactor = axisLength * 0.8 / wNorm;
                w1 *= scaleFactor;
                w2 *= scaleFactor;
                
                // Draw weight vector
                const weightVector = document.createElementNS(svgNS, 'line');
                weightVector.setAttribute('x1', centerX);
                weightVector.setAttribute('y1', centerY);
                weightVector.setAttribute('x2', centerX + w1);
                weightVector.setAttribute('y2', centerY - w2); // Note: SVG y-axis is inverted
                weightVector.setAttribute('stroke', BOUNDARY_COLOR);
                weightVector.setAttribute('stroke-width', '3');
                weightVector.setAttribute('marker-end', 'url(#arrowhead-linear)');
                weightVector.setAttribute('class', 'svm-element weight-vector');
                svmGroup.appendChild(weightVector);
                
                // Add arrowhead marker with unique ID
                const defs = document.createElementNS(svgNS, 'defs');
                const marker = document.createElementNS(svgNS, 'marker');
                marker.setAttribute('id', 'arrowhead-linear');
                marker.setAttribute('markerWidth', '10');
                marker.setAttribute('markerHeight', '7');
                marker.setAttribute('refX', '10');
                marker.setAttribute('refY', '3.5');
                marker.setAttribute('orient', 'auto');
                
                const polygon = document.createElementNS(svgNS, 'polygon');
                polygon.setAttribute('points', '0 0, 10 3.5, 0 7');
                polygon.setAttribute('fill', BOUNDARY_COLOR);
                
                marker.appendChild(polygon);
                defs.appendChild(marker);
                svmGroup.appendChild(defs);
                
                // Add bias text - moved down for more space
                const biasText = document.createElementNS(svgNS, 'text');
                biasText.setAttribute('x', centerX);
                biasText.setAttribute('y', centerY + axisLength + 40);
                biasText.setAttribute('text-anchor', 'middle');
                biasText.setAttribute('fill', document.body.classList.contains('dark') ? '#d1d5db' : '#1f2937');
                biasText.setAttribute('class', 'svm-element');
                biasText.textContent = `Bias (b): ${bias.toFixed(3)}`;
                svmGroup.appendChild(biasText);
                
                // Animate the weight vector
                anime({
                    targets: '.weight-vector',
                    strokeDashoffset: [anime.setDashoffset, 0],
                    easing: 'easeInOutSine',
                    duration: 1000
                });
            }
            
            // Add explanation text with better spacing
            const explanation = document.createElementNS(svgNS, 'text');
            explanation.setAttribute('x', SVM_X + 30);
            explanation.setAttribute('y', SVM_Y + SVM_HEIGHT - 50);
            explanation.setAttribute('fill', document.body.classList.contains('dark') ? '#d1d5db' : '#1f2937');
            explanation.setAttribute('class', 'svm-element');
            explanation.textContent = 'Decision function: f(x) = w¬∑x + b';
            svmGroup.appendChild(explanation);
            
            const explanation2 = document.createElementNS(svgNS, 'text');
            explanation2.setAttribute('x', SVM_X + 30);
            explanation2.setAttribute('y', SVM_Y + SVM_HEIGHT - 25);
            explanation2.setAttribute('fill', document.body.classList.contains('dark') ? '#d1d5db' : '#1f2937');
            explanation2.setAttribute('class', 'svm-element');
            explanation2.textContent = 'Linear kernel directly uses the weight vector in original space';
            svmGroup.appendChild(explanation2);
        }
        
        // Visualize polynomial SVM model space
        function visualizePolynomialSVMSpace(svmGroup) {
            // For polynomial SVM, visualize the feature mapping
            
            // Title with more space at the top
            const title = document.createElementNS(svgNS, 'text');
            title.setAttribute('x', SVM_X + SVM_WIDTH / 2);
            title.setAttribute('y', SVM_Y + 30);
            title.setAttribute('text-anchor', 'middle');
            title.setAttribute('font-size', '16');
            title.setAttribute('fill', document.body.classList.contains('dark') ? '#d1d5db' : '#1f2937');
            title.setAttribute('class', 'svm-element');
            title.textContent = `Polynomial Kernel (degree ${degree}) Feature Space`;
            svmGroup.appendChild(title);
            
            // Create a representation of the polynomial mapping
            const centerX = SVM_X + SVM_WIDTH / 2;
            const centerY = SVM_Y + SVM_HEIGHT / 2 + 20; // Move down slightly for more space
            const boxWidth = SVM_WIDTH * 0.75; // Reduced slightly to prevent crowding
            const boxHeight = SVM_HEIGHT * 0.55; // Reduced slightly
            
            // Input space box
            const inputBox = document.createElementNS(svgNS, 'rect');
            inputBox.setAttribute('x', centerX - boxWidth / 2 + boxWidth / 8); // Shift left box left
            inputBox.setAttribute('y', centerY - boxHeight / 2);
            inputBox.setAttribute('width', boxWidth / 3);
            inputBox.setAttribute('height', boxHeight);
            inputBox.setAttribute('fill', 'none');
            inputBox.setAttribute('stroke', document.body.classList.contains('dark') ? '#d1d5db' : '#1f2937');
            inputBox.setAttribute('stroke-width', '2');
            inputBox.setAttribute('rx', '10');
            inputBox.setAttribute('class', 'svm-element');
            svmGroup.appendChild(inputBox);
            
            // Input space label
            const inputLabel = document.createElementNS(svgNS, 'text');
            inputLabel.setAttribute('x', centerX - boxWidth / 3 + boxWidth / 8); // Match box shift
            inputLabel.setAttribute('y', centerY + boxHeight / 2 + 20); // Move below the box
            inputLabel.setAttribute('text-anchor', 'middle');
            inputLabel.setAttribute('fill', document.body.classList.contains('dark') ? '#d1d5db' : '#1f2937');
            inputLabel.setAttribute('class', 'svm-element');
            inputLabel.textContent = 'Input Space';
            svmGroup.appendChild(inputLabel);
            
            // Input space points
            const inputPoints = [];
            for (let i = 0; i < 5; i++) {
                const x = centerX - boxWidth / 3 + (i % 2) * boxWidth / 6 + 20; // Match box shift
                const y = centerY - boxHeight / 3 + Math.floor(i / 2) * boxHeight / 3;
                
                const point = document.createElementNS(svgNS, 'circle');
                point.setAttribute('cx', x);
                point.setAttribute('cy', y);
                point.setAttribute('r', '5');
                point.setAttribute('fill', i < 3 ? CLASS_1_COLOR : CLASS_0_COLOR);
                point.setAttribute('class', 'svm-element input-point');
                point.setAttribute('data-index', i);
                
                inputPoints.push({x, y});
                svmGroup.appendChild(point);
            }
            
            // Arrow
            const arrow = document.createElementNS(svgNS, 'line');
            arrow.setAttribute('x1', centerX - boxWidth / 6 + boxWidth / 8); // Adjust start for left box shift
            arrow.setAttribute('y1', centerY);
            arrow.setAttribute('x2', centerX + boxWidth / 6 - boxWidth / 8); // Adjust end for right box shift
            arrow.setAttribute('y2', centerY);
            arrow.setAttribute('stroke', BOUNDARY_COLOR);
            arrow.setAttribute('stroke-width', '3');
            arrow.setAttribute('marker-end', 'url(#arrowhead-poly)');
            arrow.setAttribute('class', 'svm-element');
            svmGroup.appendChild(arrow);
            
            // Add arrowhead marker with unique ID
            const defs = document.createElementNS(svgNS, 'defs');
            const marker = document.createElementNS(svgNS, 'marker');
            marker.setAttribute('id', 'arrowhead-poly');
            marker.setAttribute('markerWidth', '10');
            marker.setAttribute('markerHeight', '7');
            marker.setAttribute('refX', '10');
            marker.setAttribute('refY', '3.5');
            marker.setAttribute('orient', 'auto');
            
            const polygon = document.createElementNS(svgNS, 'polygon');
            polygon.setAttribute('points', '0 0, 10 3.5, 0 7');
            polygon.setAttribute('fill', BOUNDARY_COLOR);
            
            marker.appendChild(polygon);
            defs.appendChild(marker);
            svmGroup.appendChild(defs);
            
            // Mapping label - moved up for more space
            const mappingLabel = document.createElementNS(svgNS, 'text');
            mappingLabel.setAttribute('x', centerX);
            mappingLabel.setAttribute('y', centerY - boxHeight / 2 - 15);
            mappingLabel.setAttribute('text-anchor', 'middle');
            mappingLabel.setAttribute('fill', BOUNDARY_COLOR);
            mappingLabel.setAttribute('class', 'svm-element');
            mappingLabel.textContent = `Œ¶(x) = (1, x‚ÇÅ, x‚ÇÇ, x‚ÇÅ¬≤, x‚ÇÅx‚ÇÇ, x‚ÇÇ¬≤, ...)`;
            svmGroup.appendChild(mappingLabel);
            
            // Feature space box
            const featureBox = document.createElementNS(svgNS, 'rect');
            featureBox.setAttribute('x', centerX + boxWidth / 6 - boxWidth / 8); // Shift right box right
            featureBox.setAttribute('y', centerY - boxHeight / 2);
            featureBox.setAttribute('width', boxWidth / 3);
            featureBox.setAttribute('height', boxHeight);
            featureBox.setAttribute('fill', 'none');
            featureBox.setAttribute('stroke', document.body.classList.contains('dark') ? '#d1d5db' : '#1f2937');
            featureBox.setAttribute('stroke-width', '2');
            featureBox.setAttribute('rx', '10');
            featureBox.setAttribute('class', 'svm-element');
            svmGroup.appendChild(featureBox);
            
            // Feature space label
            const featureLabel = document.createElementNS(svgNS, 'text');
            featureLabel.setAttribute('x', centerX + boxWidth / 3 - boxWidth / 8); // Match box shift
            featureLabel.setAttribute('y', centerY + boxHeight / 2 + 20); // Move below the box
            featureLabel.setAttribute('text-anchor', 'middle');
            featureLabel.setAttribute('fill', document.body.classList.contains('dark') ? '#d1d5db' : '#1f2937');
            featureLabel.setAttribute('class', 'svm-element');
            featureLabel.textContent = 'Feature Space';
            svmGroup.appendChild(featureLabel);
            
            // Feature space points - arranged in a way that suggests linear separability
            const featurePoints = [];
            for (let i = 0; i < 5; i++) {
                let x, y;
                
                if (i < 3) { // Class 1 points at the top
                    x = centerX + boxWidth / 6 + (i % 3) * boxWidth / 12 - 20; // Match box shift
                    y = centerY - boxHeight / 3;
                } else { // Class 0 points at the bottom
                    x = centerX + boxWidth / 6 + ((i - 3) % 2) * boxWidth / 8 - 20 / 8; // Match box shift
                    y = centerY + boxHeight / 4;
                }
                
                const point = document.createElementNS(svgNS, 'circle');
                point.setAttribute('cx', x);
                point.setAttribute('cy', y);
                point.setAttribute('r', '5');
                point.setAttribute('fill', i < 3 ? CLASS_1_COLOR : CLASS_0_COLOR);
                point.setAttribute('class', 'svm-element feature-point');
                point.setAttribute('data-index', i);
                
                featurePoints.push({x, y});
                svmGroup.appendChild(point);
            }
            
            // Decision hyperplane in feature space (just a line for visualization)
            const hyperplane = document.createElementNS(svgNS, 'line');
            hyperplane.setAttribute('x1', centerX + boxWidth / 6 - boxWidth / 8); // Match box shift
            hyperplane.setAttribute('y1', centerY - boxHeight / 10);
            hyperplane.setAttribute('x2', centerX + boxWidth / 6 + boxWidth / 4 - boxWidth / 8); // Match box shift
            hyperplane.setAttribute('y2', centerY - boxHeight / 10);
            hyperplane.setAttribute('stroke', BOUNDARY_COLOR);
            hyperplane.setAttribute('stroke-width', '2');
            hyperplane.setAttribute('class', 'svm-element hyperplane');
            svmGroup.appendChild(hyperplane);
            
            // Animate points and hyperplane
            anime({
                targets: '.input-point',
                scale: [0, 1],
                opacity: [0, 1],
                delay: anime.stagger(200),
                easing: 'easeOutElastic(1, .5)',
                duration: 1000
            });
            
            anime({
                targets: '.feature-point',
                scale: [0, 1],
                opacity: [0, 1],
                delay: anime.stagger(200, {start: 1000}),
                easing: 'easeOutElastic(1, .5)',
                duration: 1000
            });
            
            anime({
                targets: '.hyperplane',
                strokeDashoffset: [anime.setDashoffset, 0],
                delay: 2000,
                easing: 'easeInOutSine',
                duration: 1000
            });
            
            // Add explanation text with better spacing
            const explanation = document.createElementNS(svgNS, 'text');
            explanation.setAttribute('x', SVM_X + 30);
            explanation.setAttribute('y', SVM_Y + SVM_HEIGHT +25);
            explanation.setAttribute('fill', document.body.classList.contains('dark') ? '#d1d5db' : '#1f2937');
            explanation.setAttribute('class', 'svm-element');
            explanation.textContent = `Kernel: K(x,y) = (x¬∑y + 1)^${degree}`;
            svmGroup.appendChild(explanation);
            
            const explanation2 = document.createElementNS(svgNS, 'text');
            explanation2.setAttribute('x', SVM_X + 30);
            explanation2.setAttribute('y', SVM_Y + SVM_HEIGHT + 50);
            explanation2.setAttribute('fill', document.body.classList.contains('dark') ? '#d1d5db' : '#1f2937');
            explanation2.setAttribute('class', 'svm-element');
            explanation2.textContent = `Higher degree creates more complex decision boundaries`;
            svmGroup.appendChild(explanation2);
        }
        
        // Visualize RBF SVM model space
        function visualizeRBFSVMSpace(svmGroup) {
            // For RBF SVM, visualize the feature mapping to an infinite-dimensional space
            
            // Title with more space at the top
            const title = document.createElementNS(svgNS, 'text');
            title.setAttribute('x', SVM_X + SVM_WIDTH / 2);
            title.setAttribute('y', SVM_Y + 30);
            title.setAttribute('text-anchor', 'middle');
            title.setAttribute('font-size', '16');
            title.setAttribute('fill', document.body.classList.contains('dark') ? '#d1d5db' : '#1f2937');
            title.setAttribute('class', 'svm-element');
            title.textContent = `RBF Kernel (Œ≥=${gamma}) Feature Space`;
            svmGroup.appendChild(title);
            
            // Create a representation of the RBF mapping
            const centerX = SVM_X + SVM_WIDTH / 2;
            const centerY = SVM_Y + SVM_HEIGHT / 2 + 20; // Move down slightly for more space
            const boxWidth = SVM_WIDTH * 0.75; // Reduced slightly to prevent crowding
            const boxHeight = SVM_HEIGHT * 0.55; // Reduced slightly
            
            // Input space box - shifted left
            const inputBox = document.createElementNS(svgNS, 'rect');
            inputBox.setAttribute('x', centerX - boxWidth / 2 + boxWidth / 8); // Shift left box left
            inputBox.setAttribute('y', centerY - boxHeight / 2);
            inputBox.setAttribute('width', boxWidth / 3);
            inputBox.setAttribute('height', boxHeight);
            inputBox.setAttribute('fill', 'none');
            inputBox.setAttribute('stroke', document.body.classList.contains('dark') ? '#d1d5db' : '#1f2937');
            inputBox.setAttribute('stroke-width', '2');
            inputBox.setAttribute('rx', '10');
            inputBox.setAttribute('class', 'svm-element');
            svmGroup.appendChild(inputBox);
            
            // Input space label - moved below the box
            const inputLabel = document.createElementNS(svgNS, 'text');
            inputLabel.setAttribute('x', centerX - boxWidth / 3 + boxWidth / 8); // Match box shift
            inputLabel.setAttribute('y', centerY + boxHeight / 2 + 20); // Move below the box
            inputLabel.setAttribute('text-anchor', 'middle');
            inputLabel.setAttribute('fill', document.body.classList.contains('dark') ? '#d1d5db' : '#1f2937');
            inputLabel.setAttribute('class', 'svm-element');
            inputLabel.textContent = 'Input Space';
            svmGroup.appendChild(inputLabel);
            
            // Create 2D data points for visualization
            const inputPoints = [];
            for (let i = 0; i < 12; i++) {
                let x, y;
                
                if (i < 6) { // Class 1 - inner circle
                    const angle = (i / 6) * 2 * Math.PI;
                    const radius = boxHeight / 6;
                    x = centerX - boxWidth / 3 + boxWidth / 6 + radius * Math.cos(angle) -20; // Match box shift
                    y = centerY + radius * Math.sin(angle);
                } else { // Class 0 - outer circle
                    const angle = ((i - 6) / 6) * 2 * Math.PI;
                    const radius = boxHeight / 3;
                    x = centerX - boxWidth / 3 + boxWidth / 6 + radius * Math.cos(angle) -20; // Match box shift
                    y = centerY + radius * Math.sin(angle);
                }
                
                const point = document.createElementNS(svgNS, 'circle');
                point.setAttribute('cx', x);
                point.setAttribute('cy', y);
                point.setAttribute('r', '5');
                point.setAttribute('fill', i < 6 ? CLASS_1_COLOR : CLASS_0_COLOR);
                point.setAttribute('class', 'svm-element input-point');
                point.setAttribute('data-index', i);
                
                inputPoints.push({x, y, class: i < 6 ? 1 : 0});
                svmGroup.appendChild(point);
            }
            
            // Arrow with adjusted position
            const arrow = document.createElementNS(svgNS, 'line');
            arrow.setAttribute('x1', centerX - boxWidth / 6 + boxWidth / 8); // Adjust start for left box shift
            arrow.setAttribute('y1', centerY);
            arrow.setAttribute('x2', centerX + boxWidth / 6 - boxWidth / 8); // Adjust end for right box shift
            arrow.setAttribute('y2', centerY);
            arrow.setAttribute('stroke', BOUNDARY_COLOR);
            arrow.setAttribute('stroke-width', '3');
            arrow.setAttribute('marker-end', 'url(#arrowhead-rbf)'); // Use unique marker ID
            arrow.setAttribute('class', 'svm-element');
            svmGroup.appendChild(arrow);
            
            // Add arrowhead marker with unique ID
            const defs = document.createElementNS(svgNS, 'defs');
            const marker = document.createElementNS(svgNS, 'marker');
            marker.setAttribute('id', 'arrowhead-rbf');
            marker.setAttribute('markerWidth', '10');
            marker.setAttribute('markerHeight', '7');
            marker.setAttribute('refX', '10');
            marker.setAttribute('refY', '3.5');
            marker.setAttribute('orient', 'auto');
            
            const polygon = document.createElementNS(svgNS, 'polygon');
            polygon.setAttribute('points', '0 0, 10 3.5, 0 7');
            polygon.setAttribute('fill', BOUNDARY_COLOR);
            
            marker.appendChild(polygon);
            defs.appendChild(marker);
            svmGroup.appendChild(defs);
            
            // Mapping label - positioned above for clarity
            const mappingLabel = document.createElementNS(svgNS, 'text');
            mappingLabel.setAttribute('x', centerX);
            mappingLabel.setAttribute('y', centerY - boxHeight / 2 - 15); // Moved up for more space
            mappingLabel.setAttribute('text-anchor', 'middle');
            mappingLabel.setAttribute('fill', BOUNDARY_COLOR);
            mappingLabel.setAttribute('class', 'svm-element');
            mappingLabel.textContent = `Œ¶(x) maps to ‚àû-dimensional space`;
            svmGroup.appendChild(mappingLabel);
            
            // Feature space representation (higher dimensional) - shifted right
            const featureBox = document.createElementNS(svgNS, 'ellipse');
            featureBox.setAttribute('cx', centerX + boxWidth / 3 - boxWidth / 8); // Shift right for balance
            featureBox.setAttribute('cy', centerY);
            featureBox.setAttribute('rx', boxWidth / 6);
            featureBox.setAttribute('ry', boxHeight / 2);
            featureBox.setAttribute('fill', 'none');
            featureBox.setAttribute('stroke', document.body.classList.contains('dark') ? '#d1d5db' : '#1f2937');
            featureBox.setAttribute('stroke-width', '2');
            featureBox.setAttribute('class', 'svm-element');
            svmGroup.appendChild(featureBox);
            
            // Feature space label - moved below
            const featureLabel = document.createElementNS(svgNS, 'text');
            featureLabel.setAttribute('x', centerX + boxWidth / 3 - boxWidth / 8); // Match ellipse x position
            featureLabel.setAttribute('y', centerY + boxHeight / 2 + 20); // Move below the box
            featureLabel.setAttribute('text-anchor', 'middle');
            featureLabel.setAttribute('fill', document.body.classList.contains('dark') ? '#d1d5db' : '#1f2937');
            featureLabel.setAttribute('class', 'svm-element');
            featureLabel.textContent = 'Feature Space';
            svmGroup.appendChild(featureLabel);
            
            // Feature space points - now arranged on a hemisphere to show linear separability
            const featurePoints = [];
            for (let i = 0; i < inputPoints.length; i++) {
                let x, y;
                const point = inputPoints[i];
                
                if (point.class === 1) { // Class 1 - top of hemisphere
                    const angle = (i / 6) * Math.PI;
                    x = centerX + boxWidth / 3 + Math.cos(angle) * boxWidth / 12 - boxWidth / 8; // Match ellipse shift
                    y = centerY - boxHeight / 3;
                } else { // Class 0 - around the perimeter
                    const angle = ((i - 6) / 6) * 2 * Math.PI;
                    x = centerX + boxWidth / 3 + Math.cos(angle) * boxWidth / 8 - boxWidth / 8; // Match ellipse shift
                    y = centerY + Math.sin(angle) * boxHeight / 4;
                }
                
                const featurePoint = document.createElementNS(svgNS, 'circle');
                featurePoint.setAttribute('cx', x);
                featurePoint.setAttribute('cy', y);
                featurePoint.setAttribute('r', '5');
                featurePoint.setAttribute('fill', point.class === 1 ? CLASS_1_COLOR : CLASS_0_COLOR);
                featurePoint.setAttribute('class', 'svm-element feature-point');
                featurePoint.setAttribute('data-index', i);
                
                featurePoints.push({x, y});
                svmGroup.appendChild(featurePoint);
            }
            
            // Decision hyperplane in feature space (a line that separates the classes)
            const hyperplane = document.createElementNS(svgNS, 'line');
            hyperplane.setAttribute('x1', centerX + boxWidth / 6 - boxWidth / 8);
            hyperplane.setAttribute('y1', centerY - boxHeight / 10);
            hyperplane.setAttribute('x2', centerX + boxWidth / 2 - boxWidth / 8);
            hyperplane.setAttribute('y2', centerY - boxHeight / 10);
            hyperplane.setAttribute('stroke', BOUNDARY_COLOR);
            hyperplane.setAttribute('stroke-width', '2');
            hyperplane.setAttribute('class', 'svm-element hyperplane');
            svmGroup.appendChild(hyperplane);
            
            // Animate points and hyperplane
            anime({
                targets: '.input-point',
                scale: [0, 1],
                opacity: [0, 1],
                delay: anime.stagger(100),
                easing: 'easeOutElastic(1, .5)',
                duration: 1000
            });
            
            anime({
                targets: '.feature-point',
                scale: [0, 1],
                opacity: [0, 1],
                delay: anime.stagger(100, {start: 1000}),
                easing: 'easeOutElastic(1, .5)',
                duration: 1000
            });
            
            anime({
                targets: '.hyperplane',
                strokeDashoffset: [anime.setDashoffset, 0],
                delay: 2000,
                easing: 'easeInOutSine',
                duration: 1000
            });
            
            // Add explanation text with better spacing
            const explanation = document.createElementNS(svgNS, 'text');
            explanation.setAttribute('x', SVM_X + 30);
            explanation.setAttribute('y', SVM_Y + SVM_HEIGHT + 25);
            explanation.setAttribute('fill', document.body.classList.contains('dark') ? '#d1d5db' : '#1f2937');
            explanation.setAttribute('class', 'svm-element');
            explanation.textContent = `Kernel: K(x,y) = exp(-Œ≥||x-y||¬≤)`;
            svmGroup.appendChild(explanation);
            
            const explanation2 = document.createElementNS(svgNS, 'text');
            explanation2.setAttribute('x', SVM_X + 30);
            explanation2.setAttribute('y', SVM_Y + SVM_HEIGHT + 50);
            explanation2.setAttribute('fill', document.body.classList.contains('dark') ? '#d1d5db' : '#1f2937');
            explanation2.setAttribute('class', 'svm-element');
            explanation2.textContent = `Higher Œ≥ creates tighter boundaries around data points`;
            svmGroup.appendChild(explanation2);
        }
        
        // Update the objective function plot
        function updateObjectivePlot() {
            // Remove existing objective path
            const existingPath = objectiveSvg.querySelector('.objective-path');
            if (existingPath) {
                existingPath.remove();
            }
            
            // If no objective values yet, return
            if (objectiveValues.length === 0) {
                return;
            }
            
            // Find min and max objective values for scaling
            const minObj = Math.min(...objectiveValues);
            const maxObj = Math.max(...objectiveValues);
            const range = maxObj - minObj;
            
            // Create path data
            let pathData = '';
            objectiveValues.forEach((obj, i) => {
                const x = OBJECTIVE_MARGIN + (i / (maxIterations - 1)) * (WIDTH - 2 * OBJECTIVE_MARGIN);
                const normalizedObj = (obj - minObj) / (range || 1); // Avoid division by zero
                const y = OBJECTIVE_HEIGHT - OBJECTIVE_MARGIN - normalizedObj * OBJECTIVE_PLOT_HEIGHT;
                
                if (i === 0) {
                    pathData += `M ${x},${y}`;
                } else {
                    pathData += ` L ${x},${y}`;
                }
            });
            
            // Create path element
            const path = document.createElementNS(svgNS, 'path');
            path.setAttribute('d', pathData);
            path.setAttribute('fill', 'none');
            path.setAttribute('stroke', BOUNDARY_COLOR);
            path.setAttribute('stroke-width', '3');
            path.setAttribute('class', 'objective-path');
            
            objectiveSvg.appendChild(path);
            
            // Animate the objective path
            anime({
                targets: '.objective-path',
                strokeDashoffset: [anime.setDashoffset, 0],
                easing: 'easeInOutSine',
                duration: 1000
            });
            
            // Add current iteration marker
            const currentMarker = objectiveSvg.querySelector('.current-marker');
            if (currentMarker) {
                currentMarker.remove();
            }
            
            if (currentIteration > 0) {
                const x = OBJECTIVE_MARGIN + ((currentIteration - 1) / (maxIterations - 1)) * (WIDTH - 2 * OBJECTIVE_MARGIN);
                const normalizedObj = (objectiveValues[objectiveValues.length - 1] - minObj) / (range || 1);
                const y = OBJECTIVE_HEIGHT - OBJECTIVE_MARGIN - normalizedObj * OBJECTIVE_PLOT_HEIGHT;
                
                const marker = document.createElementNS(svgNS, 'circle');
                marker.setAttribute('cx', x);
                marker.setAttribute('cy', y);
                marker.setAttribute('r', '6');
                marker.setAttribute('fill', '#EF4444');
                marker.setAttribute('class', 'current-marker');
                
                objectiveSvg.appendChild(marker);
                
                // Animate the marker
                anime({
                    targets: '.current-marker',
                    r: [0, 6],
                    opacity: [0, 1],
                    easing: 'easeOutElastic(1, .5)',
                    duration: 1000
                });
            }
        }
        
        // Simplified Sequential Minimal Optimization (SMO) step
        function smoStep() {
            if (currentIteration >= maxIterations) {
                stopAnimation();
                return;
            }
            
            currentIteration++;
            
            // Check if we have enough data points
            if (data.length < 2) {
                return;
            }
            
            // Select two random indices
            let i1 = Math.floor(Math.random() * data.length);
            let i2 = Math.floor(Math.random() * data.length);
            while (i2 === i1) {
                i2 = Math.floor(Math.random() * data.length);
            }
            
            // Compute kernel matrix for these two points
            const K11 = computeKernel(data[i1], data[i1]);
            const K12 = computeKernel(data[i1], data[i2]);
            const K22 = computeKernel(data[i2], data[i2]);
            
            // Compute errors
            const e1 = computeDecisionFunction(data[i1]) - data[i1].y;
            const e2 = computeDecisionFunction(data[i2]) - data[i2].y;
            
            // Save old alphas
            const alpha1_old = alpha[i1];
            const alpha2_old = alpha[i2];
            
            // Update alpha2
            const eta = K11 + K22 - 2 * K12;
            if (eta <= 0) {
                return; // Skip this iteration
            }
            
            let alpha2_new = alpha2_old + data[i2].y * (e1 - e2) / eta;
            
            // Apply box constraints
            const L = Math.max(0, alpha2_old + alpha1_old * data[i1].y * data[i2].y - C * (data[i1].y * data[i2].y + 1) / 2);
            const H = Math.min(C, alpha2_old + alpha1_old * data[i1].y * data[i2].y + C * (1 - data[i1].y * data[i2].y) / 2);
            
            if (alpha2_new < L) {
                alpha2_new = L;
            } else if (alpha2_new > H) {
                alpha2_new = H;
            }
            
            // Update alpha1
            const alpha1_new = alpha1_old + data[i1].y * data[i2].y * (alpha2_old - alpha2_new);
            
            // Apply updates
            alpha[i1] = alpha1_new;
            alpha[i2] = alpha2_new;
            
            // Update bias
            const b1 = bias - e1 - data[i1].y * (alpha1_new - alpha1_old) * K11 - data[i2].y * (alpha2_new - alpha2_old) * K12;
            const b2 = bias - e2 - data[i1].y * (alpha1_new - alpha1_old) * K12 - data[i2].y * (alpha2_new - alpha2_old) * K22;
            
            if (0 < alpha1_new && alpha1_new < C) {
                bias = b1;
            } else if (0 < alpha2_new && alpha2_new < C) {
                bias = b2;
            } else {
                bias = (b1 + b2) / 2;
            }
            
            // Calculate objective function
            let objective = 0;
            
            // Sum of alphas
            for (let i = 0; i < data.length; i++) {
                objective += alpha[i];
            }
            
            // Subtract quadratic term
            for (let i = 0; i < data.length; i++) {
                for (let j = 0; j < data.length; j++) {
                    objective -= 0.5 * alpha[i] * alpha[j] * data[i].y * data[j].y * computeKernel(data[i], data[j]);
                }
            }
            
            objectiveValues.push(objective);
            iterations.push(currentIteration);
            
            // Update support vector indices
            supportVectorIndices = [];
            for (let i = 0; i < data.length; i++) {
                if (Math.abs(alpha[i]) > 1e-5) {
                    supportVectorIndices.push(i);
                }
            }
            
            // Calculate accuracy
            const accuracy = calculateAccuracy();
            
            // Update UI
            currentIterationEl.textContent = `${currentIteration} / ${maxIterations}`;
            currentObjectiveEl.textContent = objective.toFixed(4);
            numSupportVectorsEl.textContent = supportVectorIndices.length;
            currentAccuracyEl.textContent = `${(accuracy * 100).toFixed(1)}%`;
            
            // Update visualizations
            visualizeDecisionBoundary();
            updateObjectivePlot();
        }
        
        // Start animation
        function startAnimation() {
            if (animationInterval) {
                clearInterval(animationInterval);
            }
            
            playBtn.textContent = 'Pause';
            playBtn.classList.remove('bg-green-600', 'hover:bg-green-700');
            playBtn.classList.add('bg-yellow-600', 'hover:bg-yellow-700');
            
            const interval = 1000 / animationSpeed;
            animationInterval = setInterval(() => {
                smoStep();
                
                if (currentIteration >= maxIterations) {
                    stopAnimation();
                }
            }, interval);
        }
        
        // Stop animation
        function stopAnimation() {
            if (animationInterval) {
                clearInterval(animationInterval);
                animationInterval = null;
            }
            
            playBtn.textContent = 'Play';
            playBtn.classList.remove('bg-yellow-600', 'hover:bg-yellow-700');
            playBtn.classList.add('bg-green-600', 'hover:bg-green-700');
        }
        
        // Event listeners
        generateDataBtn.addEventListener('click', generateData);
        
        trainSvmBtn.addEventListener('click', resetModel);
        
        resetBtn.addEventListener('click', resetModel);
        
        stepBtn.addEventListener('click', () => {
            stopAnimation();
            smoStep();
        });
        
        playBtn.addEventListener('click', () => {
            if (animationInterval) {
                stopAnimation();
            } else {
                startAnimation();
            }
        });
        
        kernelTypeSelect.addEventListener('change', () => {
            kernel = kernelTypeSelect.value;
            
            // Show/hide appropriate parameter controls
            if (kernel === 'rbf') {
                gammaContainer.style.display = 'block';
                degreeContainer.style.display = 'none';
            } else if (kernel === 'poly') {
                gammaContainer.style.display = 'none';
                degreeContainer.style.display = 'block';
            } else {
                gammaContainer.style.display = 'none';
                degreeContainer.style.display = 'none';
            }
            
            resetModel();
        });
        
        cParamInput.addEventListener('input', () => {
            C = parseFloat(cParamInput.value);
            cValueDisplay.textContent = C.toFixed(1);
        });
        
        gammaParamInput.addEventListener('input', () => {
            gamma = parseFloat(gammaParamInput.value);
            gammaValueDisplay.textContent = gamma.toFixed(2);
        });
        
        degreeParamInput.addEventListener('input', () => {
            degree = parseInt(degreeParamInput.value);
            degreeValueDisplay.textContent = degree;
        });
        
        noiseLevelInput.addEventListener('input', () => {
            noiseLevel = parseFloat(noiseLevelInput.value);
            noiseValueDisplay.textContent = noiseLevel.toFixed(2);
        });
        
        maxIterationsInput.addEventListener('change', () => {
            maxIterations = parseInt(maxIterationsInput.value);
            resetModel();
        });
        
        showMarginCheckbox.addEventListener('change', visualizeDecisionBoundary);
        showSupportVectorsCheckbox.addEventListener('change', visualizeDecisionBoundary);
        showDecisionRegionCheckbox.addEventListener('change', visualizeDecisionBoundary);
        
        animationSpeedInput.addEventListener('input', () => {
            animationSpeed = parseFloat(animationSpeedInput.value);
            animationSpeedValue.textContent = `${animationSpeed.toFixed(1)}x`;
            
            if (animationInterval) {
                stopAnimation();
                startAnimation();
            }
        });
        
        // Initialize the application
        initSVG();
        generateData();
    </script>
</body>
</html>